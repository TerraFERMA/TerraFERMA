<?xml version='1.0' encoding='utf-8'?>
<harness_options>
  <length>
    <string_value>medium</string_value>
  </length>
  <owner>
    <string_value lines="1">mspieg</string_value>
  </owner>
  <description>
    <string_value lines="1">Workflow for running and comparing a range of solver strategies for the stokes mms problem</string_value>
  </description>
  <simulations>
    <simulation name="stokes_direct">
      <input_file>
        <string_value lines="1" type="filename">mms_stokes_direct.tfml</string_value>
      </input_file>
      <run_when name="input_changed_or_output_missing"/>
      <parameter_sweep>
        <parameter name="ncells">
          <values>
            <string_value lines="1">16 32 64</string_value>
          </values>
          <update>
            <string_value lines="20" type="code" language="python">import libspud
n = int(ncells)
libspud.set_option("/geometry/mesh::Mesh/source::Rectangle/number_cells", [n, n])</string_value>
            <single_build/>
          </update>
        </parameter>
      </parameter_sweep>
      <variables>
        <variable name="error_l2_V_direct">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from math import sqrt
stat = parser("stokes.stat")
# get ||V||_2 and ||error_V||_2
l2_norm_V = sqrt(stat["Stokes"]["VelocityL2NormSquared"]["functional_value"][-1])
error_l2_V_direct = sqrt(stat["Stokes"]["VelocityL2NormErrorSquared"]["functional_value"][-1])/l2_norm_V</string_value>
        </variable>
        <variable name="error_l2_P_direct">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from math import sqrt
stat = parser("stokes.stat")
# get ||P||_2 and ||error_P||_2
l2_norm_P = sqrt(stat["Stokes"]["PressureL2NormSquared"]["functional_value"][-1])
error_l2_P_direct = sqrt(stat["Stokes"]["PressureL2NormErrorSquared"]["functional_value"][-1])/l2_norm_P</string_value>
        </variable>
        <variable name="ksp_L2residual_direct">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from glob import glob
convfile = glob("*.conv")[0]
conv = parser(convfile)
# extract the system residaul
ksp_L2residual_direct = conv['Stokes']['res_norm(l2)']</string_value>
        </variable>
      </variables>
    </simulation>
    <simulation name="stokes_fs_direct">
      <input_file>
        <string_value lines="1" type="filename">mms_stokes_fs_direct.tfml</string_value>
      </input_file>
      <run_when name="input_changed_or_output_missing"/>
      <parameter_sweep>
        <parameter name="ncells">
          <values>
            <string_value lines="1">16 32 64</string_value>
          </values>
          <update>
            <string_value lines="20" type="code" language="python">import libspud
n = int(ncells)
libspud.set_option("/geometry/mesh::Mesh/source::Rectangle/number_cells", [n, n])</string_value>
            <single_build/>
          </update>
        </parameter>
      </parameter_sweep>
      <variables>
        <variable name="error_l2_V_fs_direct">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from math import sqrt
stat = parser("stokes.stat")
# get ||V||_2 and ||error_V||_2
l2_norm_V = sqrt(stat["Stokes"]["VelocityL2NormSquared"]["functional_value"][-1])
error_l2_V_fs_direct = sqrt(stat["Stokes"]["VelocityL2NormErrorSquared"]["functional_value"][-1])/l2_norm_V</string_value>
        </variable>
        <variable name="error_l2_P_fs_direct">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from math import sqrt
stat = parser("stokes.stat")
# get ||P||_2 and ||error_P||_2
l2_norm_P = sqrt(stat["Stokes"]["PressureL2NormSquared"]["functional_value"][-1])
error_l2_P_fs_direct = sqrt(stat["Stokes"]["PressureL2NormErrorSquared"]["functional_value"][-1])/l2_norm_P</string_value>
        </variable>
        <variable name="ksp_L2residual_fs_direct">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from glob import glob
convfile = glob("*.conv")[0]
conv = parser(convfile)
# extract the system residaul
ksp_L2residual_fs_direct = conv['Stokes']['res_norm(l2)']</string_value>
        </variable>
      </variables>
    </simulation>
    <simulation name="stokes_iterative">
      <input_file>
        <string_value lines="1" type="filename">mms_stokes_iterative.tfml</string_value>
      </input_file>
      <run_when name="input_changed_or_output_missing"/>
      <parameter_sweep>
        <parameter name="ncells">
          <values>
            <string_value lines="1">16 32 64</string_value>
          </values>
          <update>
            <string_value lines="20" type="code" language="python">import libspud
n = int(ncells)
libspud.set_option("/geometry/mesh::Mesh/source::Rectangle/number_cells", [n, n])</string_value>
            <single_build/>
          </update>
        </parameter>
      </parameter_sweep>
      <variables>
        <variable name="error_l2_V_iterative">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from math import sqrt
stat = parser("stokes.stat")
# get ||V||_2 and ||error_V||_2
l2_norm_V = sqrt(stat["Stokes"]["VelocityL2NormSquared"]["functional_value"][-1])
error_l2_V_iterative = sqrt(stat["Stokes"]["VelocityL2NormErrorSquared"]["functional_value"][-1])/l2_norm_V</string_value>
        </variable>
        <variable name="error_l2_P_iterative">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from math import sqrt
stat = parser("stokes.stat")
# get ||P||_2 and ||error_P||_2
l2_norm_P = sqrt(stat["Stokes"]["PressureL2NormSquared"]["functional_value"][-1])
error_l2_P_iterative = sqrt(stat["Stokes"]["PressureL2NormErrorSquared"]["functional_value"][-1])/l2_norm_P</string_value>
        </variable>
        <variable name="ksp_L2residual_iterative">
          <string_value lines="20" type="code" language="python">from buckettools.statfile import parser
from glob import glob
convfile = glob("*.conv")[0]
conv = parser(convfile)
# extract the system residaul
ksp_L2residual_iterative = conv['Stokes']['res_norm(l2)']</string_value>
        </variable>
      </variables>
    </simulation>
  </simulations>
  <tests>
    <test name="Error_l2_V">
      <string_value lines="20" type="code" language="python">print error_l2_V_direct
print error_l2_V_fs_direct
print error_l2_V_iterative</string_value>
    </test>
    <test name="Error_l2_p">
      <string_value lines="20" type="code" language="python">print error_l2_P_direct
print error_l2_P_fs_direct
print error_l2_P_iterative</string_value>
    </test>
    <test name="PlotErrors">
      <string_value type="code" lines="20" language="python">import pylab as pl
import numpy as np

solvers = ['direct', 'fs_direct', 'iterative']
colors = ['r','b','g']
pl.figure()

for i in range(len(solvers)):
  ncells = eval("error_l2_V_"+solvers[i]+".parameters['ncells']")
  h = np.array([ 1./float(N) for N in ncells])
  #print solvers[i], ncells, h
  V_err = eval("error_l2_V_"+solvers[i]+"[{'ncells':ncells}]")
  P_err = eval("error_l2_P_"+solvers[i]+"[{'ncells':ncells}]")
  #print solvers[i], V_err, P_err
  pv=pl.polyfit(np.log(h),np.log(V_err),1)
  pp=pl.polyfit(np.log(h),np.log(P_err),1)
  llabel = solvers[i]+' $p_V$={0:2.1f} $p_p$={1:2.1f}'.format(pv[0],pp[0])
  pl.loglog(h,V_err,colors[i]+'o-',label=llabel)
  pl.hold(True)   
  pl.loglog(h,P_err,colors[i]+'s-')

pl.grid()
pl.xlabel('h')
pl.ylabel('||e||_2')

pl.title('Solver Convergence')
pl.legend(loc='best',fontsize=12)
pl.savefig('Solver_comparison_convergence.pdf')

print "Convergence plot in Solver_comparison_convergence.pdf"</string_value>
    </test>
    <test name="PlotConvergence">
      <string_value lines="20" type="code" language="python">import pylab as pl
import numpy as np

solvers = ['direct', 'fs_direct', 'iterative']
colors = ['r','b','g']
pl.figure()

# find the maximum size run common to all solvers (this is a little dodgy)
Nmax = []
for i in range(len(solvers)):
  ncells = eval("error_l2_V_"+solvers[i]+".parameters['ncells']")
  Nmax.append(max([ int(N)  for N  in ncells])) 

#convert back to a string
NPlot = "{0}".format(min(Nmax))
print Nmax, NPlot
  
#print ksp_L2residual_fs_direct
#print ksp_L2residual_fs_direct[{'ncells':NPlot}]

for i in range(len(solvers)): 
  L2res = eval("ksp_L2residual_"+solvers[i]+"[{'ncells':NPlot}]")
  kits = range(len(L2res))
#  print kits, L2res
  pl.semilogy(kits,L2res,colors[i]+'+-')
  pl.hold(True)   

pl.grid()
pl.xlabel('KSP iterations')
pl.ylabel('||r||_2')
pl.title('KSP Convergence for N={0}'.format(NPlot))
pl.legend(solvers,loc='best')
pl.savefig('Solver_Comparison_ksp_convergence.pdf')


print "KSP Convergence plot in Solver_comparison_ksp_convergence.pdf"</string_value>
    </test>
  </tests>
</harness_options>
