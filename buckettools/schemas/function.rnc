# Copyright (C) 2013 Columbia University in the City of New York and others.
#
# Please see the AUTHORS file in the main source directory for a full list
# of contributors.
#
# This file is part of TerraFERMA.
#
# TerraFERMA is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TerraFERMA is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with TerraFERMA. If not, see <http://www.gnu.org/licenses/>.

include "spud_base.rnc"
include "element.rnc"
include "ufl.rnc"

field_options =
  (
    ## Options describing a field (a prognostic function) in this system
    element field {
      field_header_options,
      (
        ## The type of field (no option available).
        ##
        ## Fields may only be prognostic functions.
        element type {
          attribute name { "Function" },
          (
            ## The rank of the field (scalar, rank 0).
            element rank {
              attribute name { "Scalar" },
              scalar_field_function_options
            }|
            ## The rank of the field (vector, rank 1).
            element rank {
              attribute name { "Vector" },
              vector_field_function_options
            }|
            ## The rank of the field (tensor, rank 2).
            element rank {
              attribute name { "Tensor" },
              tensor_field_function_options
            }
          )
        }
      ),
      field_diagnostics_options
    }
  )


coefficient_options =
  (
    ## Options describing a coefficient in this system
    element coefficient {
      coeff_header_options,
      (
        ## The type of coefficient.
        ##
        ## Expressions are not defined on functionspaces but require an element to be described in ufl.
        element type {
          attribute name { "Expression" },
          (
            ## The rank of the coefficient (scalar, rank 0).
            element rank {
              attribute name { "Scalar" },
              scalar_coefficient_expression_options
            }|
            ## The rank of the coefficient (vector, rank 1).
            element rank {
              attribute name { "Vector" },
              vector_coefficient_expression_options
            }|
            ## The rank of the coefficient (tensor, rank 2).
            element rank {
              attribute name { "Tensor" },
              tensor_coefficient_expression_options
            }
          )
        }|
        ## The type of coefficient.
        ##
        ## Constants are spatially constant expressions.
        element type {
          attribute name { "Constant" },
          (
            ## The rank of the coefficient (scalar, rank 0).
            element rank {
              attribute name { "Scalar" },
              scalar_coefficient_constant_options
            }|
            ## The rank of the coefficient (vector, rank 1).
            element rank {
              attribute name { "Vector" },
              vector_coefficient_constant_options
            }|
            ## The rank of the coefficient (tensor, rank 2).
            element rank {
              attribute name { "Tensor" },
              tensor_coefficient_constant_options
            }
          )
        }|
        ## The type of coefficient.
        ##
        ## Functions require a functionspace, which will be defined on the same mesh as the system in which this coefficient falls.
        element type {
          attribute name { "Function" },
          (
            ## The rank of the coefficient (scalar, rank 0).
            element rank {
              attribute name { "Scalar" },
              scalar_coefficient_function_options
            }|
            ## The rank of the coefficient (vector, rank 1).
            element rank {
              attribute name { "Vector" },
              vector_coefficient_function_options
            }|
            ## The rank of the coefficient (tensor, rank 2).
            element rank {
              attribute name { "Tensor" },
              tensor_coefficient_function_options
            }
          )
        }
      ),
      coeff_diagnostics_options
    }
  )

scalar_field_function_options =
  (
    attribute rank { "0" },
    element_options_scalar,
    initial_condition_scalar+,
    boundary_condition_scalar*,
    reference_point_scalar?,
    value_cap_scalar?
  )

vector_field_function_options =
  (
    attribute rank { "1" },
    element_options_vector,
    initial_condition_vector+,
    boundary_condition_vector*,
    reference_point_tensor*,
    value_cap_tensor*
  )

tensor_field_function_options =
  (
    attribute rank { "2" },
    element_options_tensor,
    initial_condition_tensor+,
    boundary_condition_tensor*,
    reference_point_tensor*,
    value_cap_tensor*
  )

field_manipulation_options = 
  (
    ## Cap the values of the field after every solve
    element value_cap {
      ## Do not let the maximum value exceed this cap
      element upper_cap {
        real
      }?,
      ## Do not let the minimum value fall below this cap
      element lower_cap {
        real
      }?
    }?
  )

scalar_coefficient_expression_options =
  (
    attribute rank { "0" },
    element_options_scalar,
    prescribed_expression_scalar+
  )

vector_coefficient_expression_options =
  (
    attribute rank { "1" },
    element_options_vector,
    prescribed_expression_vector+
  )

tensor_coefficient_expression_options =
  (
    attribute rank { "2" },
    element_options_tensor,
    prescribed_expression_tensor+
  )

scalar_coefficient_function_options =
  (
    attribute rank { "0" },
    element_options_scalar,
    prescribed_function_scalar+
  )

vector_coefficient_function_options =
  (
    attribute rank { "1" },
    element_options_vector,
    prescribed_function_vector+
  )

tensor_coefficient_function_options =
  (
    attribute rank { "2" },
    element_options_tensor,
    prescribed_function_tensor+
  )

scalar_coefficient_constant_options =
  (
    attribute rank { "0" },
    prescribed_constant_scalar
  )

vector_coefficient_constant_options =
  (
    attribute rank { "1" },
    prescribed_constant_vector
  )

tensor_coefficient_constant_options =
  (
    attribute rank { "2" },
    prescribed_constant_tensor
  )

field_header_options =
  (
    attribute name { xsd:string },
    field_ufl_symbol
  )

coeff_header_options =
  (
    attribute name { xsd:string },
    coeff_ufl_symbol
  )

field_diagnostics_options = 
  (
    ## Output options
    element diagnostics {
      ## Include this field in the visualization output file.
      element include_in_visualization {
        empty
      }?,
      ## Include this field in the statistics output file.
      ## The minimum and maximum of functions is included.
      element include_in_statistics {
        functional_options*
      }?,
      ## Include this field in the steady state check and output file.
      element include_in_steady_state {
        ## Norm to test for a steady state in 
        element norm {
          # a hard coded string_value
          element string_value {
            ( "linf" | "l2" | "l1" )
          }
        }
      }?,
      ## Include this field in the detectors output file.
      element include_in_detectors {
        empty
      }?,
      ## Include the residual of this field in a visualization output file.
      element include_residual_in_visualization {
        empty
      }?
    }
  )

coeff_diagnostics_options = 
  (
    ## Output options
    element diagnostics {
      ## Include this coefficient in the statistics output file.
      ## The minimum and maximum (evaluated at the vertices of the mesh) 
      ## of functions is included.
      element include_in_statistics {
        functional_options*
      }?,
      ## Include this coefficient in the detectors output file.
      element include_in_detectors {
        empty
      }?
    }
  )

functional_options = 
  (
    ## ufl code and symbol describing a functional.  This must return a single number and have a unique name beneath this field or coefficient.
    element functional {
      attribute name { xsd:string },
      python_code,
      functional_ufl_symbol,
      quadrature_degree,
      quadrature_rule,
      ## Include this functional in the steady state check and output file.
      element include_in_steady_state {
        empty
      }?
    }
  )

initial_condition_scalar = 
  (
    ## Options for the description of the initial condition over the whole domain
    element initial_condition {
      attribute name {"WholeMesh"},
      attribute type {"initial_condition"},
      prescribed_scalar_w_file
    }|
    ## Options for the description of the initial condition over a subset of the whole domain
    element initial_condition {
      attribute name { xsd:string },
      attribute type {"initial_condition"},
      ## A list of the region ids (physical ids in gmsh) that this  condition applies to
      element region_ids {
        integer_vector
      },
      prescribed_scalar
    }
  )

initial_condition_vector = 
  (
    ## Options for the description of the initial condition over the whole domain
    element initial_condition {
      attribute name {"WholeMesh"},
      attribute type {"initial_condition"},
      prescribed_vector_w_file
    }|
    ## Options for the description of the initial condition over a subset of the whole domain
    element initial_condition {
      attribute name { xsd:string },
      attribute type {"initial_condition"},
      ## A list of the region ids (physical ids in gmsh) that this condition applies to
      element region_ids {
        integer_vector
      },
      prescribed_vector
    }
  )

initial_condition_tensor = 
  (
    ## Options for the description of the initial condition over the whole domain
    element initial_condition {
      attribute name {"WholeMesh"},
      attribute type {"initial_condition"},
      prescribed_tensor_w_file
    }|
    ## Options for the description of the initial condition over a subset of the whole domain
    element initial_condition {
      attribute name { xsd:string },
      attribute type {"initial_condition"},
      ## A list of the region ids (physical ids in gmsh) that this condition applies to
      element region_ids {
        integer_vector
      },
      prescribed_tensor
    }
  )

boundary_condition_scalar = 
  (
    ## Options for the description of a boundary condition
    element boundary_condition {
      attribute name { xsd:string },
      ## A list of the boundary ids (physical ids in gmsh) that this condition applies to  
      element boundary_ids {
        integer_vector
      },
      ## There are no sub components to a scalar so this is just a dummy tree level for consistency with a vector function
      element sub_components {
        attribute name { "All"},
        ## The boundary condition type (only strong Dirichlet available).
        element type {
          attribute name {"Dirichlet"},
          attribute type {"boundary_condition"},
          prescribed_scalar
        }
      }
    }
  )

boundary_condition_vector = 
  (
    ## Options for the description of a boundary condition
    element boundary_condition {
      attribute name { xsd:string },
      ## A list of the boundary ids (physical ids in gmsh) that this condition applies to  
      element boundary_ids {
        integer_vector
      },
      (
        ## Apply this boundary condition to all the vector components on this boundary_id
        element sub_components {
          attribute name {"All"},
          ## The boundary condition type (only strong Dirichlet available).
          element type {
            attribute name {"Dirichlet"},
            attribute type {"boundary_condition"},
            prescribed_vector
          }
        }|
        ## Apply this boundary condition to a subset of the vector components on this boundary_id
        element sub_components {
          attribute name { xsd:string },
          ## A list of the vector components to which this boundary condition applies (indexes from 0)
          element components {
            integer_vector
          },
          ## The boundary condition type (only strong Dirichlet available).
          element type {
            attribute name {"Dirichlet"},
            attribute type {"boundary_condition"},
            prescribed_scalar
          }
        }
      )+
    }
  )

boundary_condition_tensor = 
  (
    ## Options for the description of a boundary condition
    element boundary_condition {
      attribute name { xsd:string },
      ## A list of the boundary ids (physical ids in gmsh) that this condition applies to  
      element boundary_ids {
        integer_vector
      },
      (
        ## Apply this boundary condition to all the tensor components on this boundary_id
        element sub_components {
          attribute name {"All"},
          ## The boundary condition type (only strong Dirichlet available).
          element type {
            attribute name {"Dirichlet"},
            attribute type {"boundary_condition"},
            prescribed_tensor
          }
        }|
        ## Apply this boundary condition to a subset of the tensor components on this boundary_id
        element sub_components {
          attribute name { xsd:string },
          ## A list of the tensor components to which this boundary condition applies (indexes from 0 by row first)
          element components {
            integer_vector
          },
          ## The boundary condition type (only strong Dirichlet available).
          element type {
            attribute name {"Dirichlet"},
            attribute type {"boundary_condition"},
            prescribed_scalar
          }
        }
      )+
    }
  )

reference_point_scalar = 
  (
    ## Options for the description of a reference point at which field values are zeroed.
    element reference_point {
      attribute name { "Point" },
      ## The coordinates of the reference point.  The node nearest these coordinates will be used.
      element coordinates {
        real_dim_vector
      }
    }
  )

reference_point_tensor = 
  (
    ## Options for the description of a reference point at which field values are zeroed.
    element reference_point {
      attribute name { "Point" },
      ## The coordinates of the reference point.  The node nearest these coordinates will be used.
      element coordinates {
        real_dim_vector
      },
      (
        ## Zero all the vector/tensor components at this reference point.
        element sub_components {
          attribute name {"All"},
          empty
        }|
        ## Zero a subset of the vector/tensor components at this reference point.
        element sub_components {
          attribute name { "Subset" },
          ## A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).
          element components {
            integer_vector
          }
        }
      )
    }|
    element reference_point {
      attribute name {xsd:string },
      ## The coordinates of the reference point.  The node nearest these coordinates will be used.
      element coordinates {
        real_dim_vector
      },
      (
        ## Zero a subset of the vector/tensor components at this reference point.
        element sub_components {
          attribute name { "Subset" },
          ## A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).
          element components {
            integer_vector
          }
        }|
        ## Zero all the vector/tensor components at this reference point.
        element sub_components {
          attribute name {"All"},
          empty
        }
      )
    }
  )

value_cap_scalar = 
  (
    ## Cap the values of the field after every solve
    element value_cap {
      attribute name { "Cap" },
      ## Do not let the maximum value exceed this cap
      element upper_cap {
        real
      }?,
      ## Do not let the minimum value fall below this cap
      element lower_cap {
        real
      }?
    }
  )

value_cap_tensor = 
  (
    ## Cap the values of the field after every solve
    element value_cap {
      attribute name { "Cap" },
      ## Do not let the maximum value exceed this cap
      element upper_cap {
        real
      }?,
      ## Do not let the minimum value fall below this cap
      element lower_cap {
        real
      }?,
      (
        ## Cap all the vector/tensor components.
        element sub_components {
          attribute name {"All"},
          empty
        }|
        ## Cap a subset of the vector/tensor components.
        element sub_components {
          attribute name { "Subset" },
          ## A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).
          element components {
            integer_vector
          }
        }
      )
    }|
    element value_cap {
      attribute name {xsd:string },
      ## Do not let the maximum value exceed this cap
      element upper_cap {
        real
      }?,
      ## Do not let the minimum value fall below this cap
      element lower_cap {
        real
      }?,
      (
        ## Cap all the vector/tensor components.
        element sub_components {
          attribute name {"All"},
          empty
        }|
        ## Cap a subset of the vector/tensor components.
        element sub_components {
          attribute name { "Subset" },
          ## A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).
          element components {
            integer_vector
          }
        }
      )
    }
  )


prescribed_constant_scalar = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_scalar_constant_w_functional
    }
  )

prescribed_constant_vector = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_vector_constant
    }
  )

prescribed_constant_tensor = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_tensor_constant
    }
  )

prescribed_expression_scalar = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_scalar_w_internal
    }|
    ## Options for the description of an expression over regions
    element value {
      attribute name { xsd:string },
      attribute type {"value"},
      ## A list of the region ids (physical ids in gmsh) that this expression applies to
      element region_ids {
        integer_vector
      },
      prescribed_scalar_w_internal
    }
  )

prescribed_expression_vector = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_vector_w_internal
    }|
    ## Options for the description of an expression over regions
    element value {
      attribute name { xsd:string },
      attribute type {"value"},
      ## A list of the region ids (physical ids in gmsh) that this expression applies to
      element region_ids {
        integer_vector
      },
      prescribed_vector_w_internal
    }
  )

prescribed_expression_tensor = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_tensor_w_internal
    }|
    ## Options for the description of an expression over regions
    element value {
      attribute name { xsd:string },
      attribute type {"value"},
      ## A list of the region ids (physical ids in gmsh) that this expression applies to
      element region_ids {
        integer_vector
      },
      prescribed_tensor_w_internal
    }
  )

prescribed_function_scalar = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_scalar_time_w_internal
    }|
    ## Options for the description of an expression over regions
    element value {
      attribute name { xsd:string },
      attribute type {"value"},
      ## A list of the region ids (physical ids in gmsh) that this expression applies to
      element region_ids {
        integer_vector
      },
      prescribed_scalar_time_w_internal
    }
  )

prescribed_function_vector = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_vector_time_w_internal
    }|
    ## Options for the description of an expression over regions
    element value {
      attribute name { xsd:string },
      attribute type {"value"},
      ## A list of the region ids (physical ids in gmsh) that this expression applies to
      element region_ids {
        integer_vector
      },
      prescribed_vector_time_w_internal
    }
  )

prescribed_function_tensor = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      attribute type {"value"},
      prescribed_tensor_time_w_internal
    }|
    ## Options for the description of an expression over regions
    element value {
      attribute name { xsd:string },
      attribute type {"value"},
      ## A list of the region ids (physical ids in gmsh) that this expression applies to
      element region_ids {
        integer_vector
      },
      prescribed_tensor_time_w_internal
    }
  )

prescribed_scalar_constant =
  (
    (
      ## A constant scalar
      element constant {
        real
      }
    )
  )

prescribed_scalar_functional =
  (
    (
      ## ufl code and symbol describing a functional.  This must return a single number, which is used to set a spatially constant coefficient value.
      element functional {
        attribute rank { "0" },
        python_code,
        functional_ufl_symbol,
        quadrature_degree,
        quadrature_rule
      }
    )
  )

prescribed_scalar_constant_w_functional = prescribed_scalar_functional
prescribed_scalar_constant_w_functional |= prescribed_scalar_constant

prescribed_vector_constant = 
  (
    ## A constant vector of length /geometry/dimension
    element constant {
      attribute name { "dim" },
      real_dim_vector
    }|
    ## A constant vector of arbitrary length (must be the same as the size of the vector element).
    element constant {
      attribute name { "arbitrary" },
      real_vector
    }
  )

prescribed_tensor_constant = 
  (
    ## A constant tensor of shape /geometry/dimension x /geometry/dimension
    element constant {
      attribute name { "dim" },
      real_dim_tensor
    }|
    ## A constant tensor of arbitrary shape (must be the same as the size of the tensor element).  
    ## Values should be entered by row first.
    element constant {
      attribute name { "arbitrary" },
      real_tensor
    }
  )

prescribed_scalar_python =
  (
    ## A scalar described by a python function.
    ##
    ## Functions should be of the form:
    ##
    ##  def val(x):
    ##     # Function code
    ##     return ... # Return value
    ##
    ##  for steady (time independent) expressions or:
    ##
    ##  def val(x,t):
    ##     # Function code
    ##     return ... # Return value
    ##
    ##  for time dependent expressions.
    ##
    ## The return value should be scalar.
    element python {
      attribute rank { "0" },
      python_code
    }
  )


prescribed_vector_python = 
  (
    ## A vector described by a python function.
    ##
    ## Functions should be of the form:
    ##
    ##  def val(x):
    ##     # Function code
    ##     return [..., ...] # Return value
    ##
    ##  for steady (time independent) expressions or:
    ##
    ##  def val(x,t):
    ##     # Function code
    ##     return [..., ...] # Return value
    ##
    ##  for time dependent expressions.
    ##
    ## The return value must have the same size as the vector element.
    element python {
      attribute rank { "1" },
      python_code
    }
  )

prescribed_tensor_python = 
  (
    ## A tensor described by a python function.
    ##
    ## Functions should be of the form:
    ##
    ##  def val(x):
    ##     # Function code
    ##     return [[..., ...],[..., ...],...] # Return value
    ##
    ##  for steady (time independent) expressions or:
    ##
    ##  def val(x,t):
    ##     # Function code
    ##     return [[..., ...],[..., ...],...] # Return value
    ##
    ##  for time dependent expressions.
    ##
    ## The return value must have the same shape as the tensor element.
    element python {
      attribute rank { "2" },
      python_code
    }
  )


prescribed_cpp = 
  (
    ## Additional headers that are required for this expression.
    ##
    ##
    ## These should be listed including an include statement, e.g.:
    ## #include <string>
    ## #include "example.h"
    ##
    ##
    ## The expression will automatically include:
    ##
    ## #include "BoostTypes.h"
    ##
    ## #include "Bucket.h"
    ##
    ## #include "SystemBucket.h"
    ##
    ## #include <dolfin.h>
    element include {
      cpp_code
    }?,
    ## Private members of this expression. These are variables that will be used in the eval
    ## function for this expression but that you don't want initialized at every call to the eval
    ## (expensive).  They should therefore be declared here and initialized in the initialization 
    ## routines below.
    ##
    ## The use of underscores at the end of variable names is discouraged as these are frequesntly used for 
    ## automatically generated variables.  Additionally the overloaded dolfin eval interface provides
    ## variables named values, x and cell, so these should not be used to avoid confusion.
    element members {
      cpp_code
    },
    ## Initialization routine for the private members declared above.
    ##
    ##
    ## This initialization has full access to publicly accessible members of the bucket through
    ## the automatically provided bucket() function, which returns a pointer to the bucket class.  
    ## A shortcut to the members of this system is provided through the system() function, which 
    ## returns a pointer to this system class.  Finally, a boost shared pointer to the time is
    ## provided through the time() function.
    ##
    ##
    ## The recommended way of accessing functions is through the function_ptr(time()) interface for
    ## systems and the genericfunction_ptr(time()) interface for fields and coefficients.  These return
    ## a boost shared pointer to a dolfin function or generic function respectively.  Importantly however,
    ## the time() argument will ensure that when this expression is evaluated the appropriate timelevel of 
    ## dependent function or generic function is also used. *time() may also be used to make the expression
    ## dependent on time.
    ##
    ##
    ## For example, to extract a boost shared pointer to a generic function for a coefficient called 
    ## "ExampleCoefficient", we should have declared in the members section above:
    ##
    ## std::shared_pointer< dolfin::GenericFunction > examplecoeff;
    ##
    ## or (utilizing the typedefs available to us through BoostTypes.h:
    ##
    ## GenericFunction_ptr examplecoeff;
    ##
    ##
    ## Then, in this initialization function, we could extract the appropriate time level of that 
    ## coefficient from the "ExampleSystem" system using:
    ##
    ## examplecoeff = bucket()->fetch_system("ExampleSystem")->fetch_coeff("ExampleCoefficient")->genericfunction_ptr(time())
    ##
    ## or, if "ExampleSystem" is the current system, using the shortcut:
    ##
    ## examplecoeff = system()->fetch_coeff("ExampleCoefficient")->genericfunction_ptr(time())
    ##
    element initialization {
      cpp_code
    },
    ## Overload the eval subroutine for this expression.  This has the standard interface for DOLFIN 
    ## expressions, i.e.:
    ##
    ## void eval(dolfin::Array<double>& values, const dolfin::Array<double>& x, const ufc::cell &cell) const
    ##
    ##
    ## To automatically evaluate and return the values of the "ExampleCoefficient" in the example in the 
    ## initialization section, all that would be required to write here is:
    ##
    ## examplecoeff.eval(values, x, cell);
    ##
    ## (assuming examplecoeff and this expression are of appropriately matched rank, shape and size).
    ##
    element eval {
      cpp_code
    }
  )

time_independent_cpp = 
  (
    ## cpp functions are automatically assumed to be time varying.  
    ##
    ## Turning on this option means they only get evaluated once (at
    ## the start of the simtulation).
    element time_independent {
      empty
    }?
  )

prescribed_cpp_time = prescribed_cpp
prescribed_cpp_time &= time_independent_cpp

prescribed_scalar_cpp =
  (
    ## A scalar described by a derived dolfin expression using c++ code.
    element cpp {
      attribute rank { "0" },
      prescribed_cpp
    }
  )

prescribed_vector_cpp =
  (
    ## A vector described by a derived dolfin expression using c++ code.
    element cpp {
      attribute rank { "1" },
      prescribed_cpp
    }
  )

prescribed_tensor_cpp =
  (
    ## A tensor described by a derived dolfin expression using c++ code.
    element cpp {
      attribute rank { "2" },
      prescribed_cpp
    }
  )

prescribed_scalar_cpp_time =
  (
    ## A scalar described by a derived dolfin expression using c++ code.
    element cpp {
      attribute rank { "0" },
      prescribed_cpp_time
    }
  )

prescribed_vector_cpp_time =
  (
    ## A vector described by a derived dolfin expression using c++ code.
    element cpp {
      attribute rank { "1" },
      prescribed_cpp_time
    }
  )

prescribed_tensor_cpp_time =
  (
    ## A tensor described by a derived dolfin expression using c++ code.
    element cpp {
      attribute rank { "2" },
      prescribed_cpp_time
    }
  )

prescribed_internal = 
  (
    (
      ## A semilagrangian lookup algorithm
      element algorithm {
        attribute name { "SemiLagrangian" },
        ## The function that will be looked up (normally a field).
        ##
        ## Note that the algorithm will always look up the value of the function at the previous timestep.
        element lookup_function {
          ## The system where the function is to be found.
          ## Assumed to be the current system if left unspecified.
          element system {
            attribute name { xsd:string },
            empty
          }?,
          (
            ## The field name.
            element field {
              attribute name { xsd:string },
              empty
            }|
            ## The coefficient name.
            element coefficient {
              attribute name { xsd:string },
              empty
            }
          )
        },
        ## The velocity that will be used to lookup the value.
        ##
        ## This must have the same dimension as the geometry.
        element velocity {
          ## The system where the velocity is to be found.
          ## Assumed to be the current system if left unspecified.
          element system {
            attribute name { xsd:string },
            empty
          }?,
          (
            ## The field name.
            element field {
              attribute name { xsd:string },
              empty
            }|
            ## The coefficient name.
            element coefficient {
              attribute name { xsd:string },
              empty
            }
          )
        },
        ## The value that will be used when the lookup point falls outside the mesh.
        ##
        ## Most likely this should be a coefficient expression or constant (i.e. not restricted to the system's mesh).
        element outside_value {
          ## The system where the function is to be found.
          ## Assumed to be the current system if left unspecified.
          element system {
            attribute name { xsd:string },
            empty
          }?,
          (
            ## The coefficient name.
            element coefficient {
              attribute name { xsd:string },
              empty
            }|
            ## The field name.
            element field {
              attribute name { xsd:string },
              empty
            }
          )
        }
      }
    )
  )

prescribed_scalar_internal =
  (
    ## A scalar described by an internal derived dolfin expression.
    element internal {
      attribute rank { "0" },
      prescribed_internal
    }
  )

prescribed_vector_internal =
  (
    ## A vector described by an internal derived dolfin expression.
    element internal {
      attribute rank { "1" },
      prescribed_internal
    }
  )

prescribed_tensor_internal =
  (
    ## A tensor described by an internal derived dolfin expression.
    element internal {
      attribute rank { "2" },
      prescribed_internal
    }
  )

prescribed_file = 
  (
    ## Give the name of a checkpoint file.  All fields in a system must share this file
    ## and the functionspace must be identical to the original system's functionspace.
    element file {
      anystring
    }
  )

prescribed_scalar = prescribed_scalar_cpp
prescribed_scalar |= prescribed_scalar_python
prescribed_scalar |= prescribed_scalar_constant

prescribed_scalar_w_internal = prescribed_scalar_internal
prescribed_scalar_w_internal |= prescribed_scalar

prescribed_scalar_w_file = prescribed_file
prescribed_scalar_w_file |= prescribed_scalar

prescribed_scalar_time = prescribed_scalar_cpp_time
prescribed_scalar_time |= prescribed_scalar_python
prescribed_scalar_time |= prescribed_scalar_constant

prescribed_scalar_time_w_internal = prescribed_scalar_internal
prescribed_scalar_time_w_internal |= prescribed_scalar_time

prescribed_vector = prescribed_vector_cpp
prescribed_vector |= prescribed_vector_python
prescribed_vector |= prescribed_vector_constant

prescribed_vector_w_internal = prescribed_vector_internal
prescribed_vector_w_internal |= prescribed_vector

prescribed_vector_w_file = prescribed_file
prescribed_vector_w_file |= prescribed_vector

prescribed_vector_time = prescribed_vector_cpp_time
prescribed_vector_time |= prescribed_vector_python
prescribed_vector_time |= prescribed_vector_constant

prescribed_vector_time_w_internal = prescribed_vector_internal
prescribed_vector_time_w_internal |= prescribed_vector_time

prescribed_tensor = prescribed_tensor_cpp
prescribed_tensor |= prescribed_tensor_python
prescribed_tensor |= prescribed_tensor_constant

prescribed_tensor_w_internal = prescribed_tensor_internal
prescribed_tensor_w_internal |= prescribed_tensor

prescribed_tensor_w_file = prescribed_file
prescribed_tensor_w_file |= prescribed_tensor

prescribed_tensor_time = prescribed_tensor_cpp_time
prescribed_tensor_time |= prescribed_tensor_python
prescribed_tensor_time |= prescribed_tensor_constant

prescribed_tensor_time_w_internal = prescribed_tensor_internal
prescribed_tensor_time_w_internal |= prescribed_tensor_time

