# Copyright (C) 2013 Columbia University in the City of New York and others.
#
# Please see the AUTHORS file in the main source directory for a full list
# of contributors.
#
# This file is part of TerraFERMA.
#
# TerraFERMA is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TerraFERMA is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with TerraFERMA. If not, see <http://www.gnu.org/licenses/>.

include "spud_base.rnc"

timestepping =
   (
      ## Options for timestepping if this is a dynamic simulation (leave inactive for steady state simulations)
      element timestepping {
        ## The current time at the start of the simulation
        element current_time {
          real
        },
        (
          ## The time at which the simulation should stop
          element finish_time {
            real
          }|
          ## The number of timesteps after which the simulation should stop
          element number_timesteps {
            integer
          }
        ),
        ## Options for the timestep
        element timestep {
          ## Options describing a coefficient in this system
          element coefficient {
            attribute name { "Timestep" },
            special_ufl_symbol,
            ## The type of coefficient.
            ##
            ## Constants are spatially constant expressions.
            element type {
              attribute name { "Constant" },
              ## The rank of the coefficient (scalar, rank 0).
              element rank {
                attribute name { "Scalar" },
                timestep_constant_options,
                comment
              },
              comment
            },
            comment
          },
          ## Options to adapt the timestep based on a field in a system
          element adaptive {
            ## Provide the name of a field (and the system it is described in) and its target maximum value.
            ##
            ## This should be a Courant number like field so that the timestep is calculated such that:
            ##
            ## dt = (current_dt*requested_maximum_value)/current_maximum_value
            ##
            ## If multiple constraints are provided the minimum timestep is taken.
            element constraint {
              attribute name { xsd:string },
              ## The system name
              element system {
                attribute name { xsd:string },
                comment
              },
              (
                ## The field name
                ##
                ## Field is assumed to be Scalar.
                element field {
                  attribute name { xsd:string },
                  comment
                }|
                ## The coefficient name
                ##
                ## Coefficient is assumed to be Scalar.
                element coefficient {
                  attribute name { xsd:string },
                  comment
                }
              ),
              ## The target maximum value requested for the above field
              element requested_maximum_value {
                real
              },
              comment
            }+,
            (
              ## The period in simulation time at which the timestep is recalculated.
              ##
              ## Defaults to every timestep if not selected.
              element adapt_period {
                real
              }|
              ## The number of timesteps between recalculations of the optimal timestep.
              ##
              ## Defaults to 1 (every timestep) if not selected.
              element adapt_period_in_timesteps {
                integer
              }
            )?,
            ## The maximum ratio by which the timestep is allowed
            ## to increase in a timestep adapt. e.g., a value of
            ## 1.1 indicates that the timestep may be increased by
            ## at most 10%.
            element increase_tolerance {
              real
            }?,
            comment
          }?,
          comment
        },
        ## Check for a steady state by comparing the previous timestep's values
        ## to the most recent compared to the given tolerance in the given norm
        element steady_state {
          ## Tolerance in which to test for a steady state
          element tolerance {
            real
          },
          comment
        }?,
        ## Set a walltime limit (in seconds) after which the simulation will be terminated.
        ##
        ## Useful in combination with checkpointing on clusters.
        element walltime_limit {
          real
        }?,
        comment
      }
   )

timestep_constant_options =
  (
    attribute rank { "0" },
    constant_timestep
  )

constant_timestep = 
  (
    ## Options for the description of an expression over the domain
    element value {
      attribute name {"WholeMesh"},
      prescribed_scalar_constant,
      comment
    }
  )

nonlinear_systems_tolerances =
   (
      ## The relative error allowed to remain in the vector l2 norm of the combined systems residual upon termination
      ## of the iteration loop.
      ##
      ## If a system contains multiple solvers, the residual defined in the last solver is taken as that system's
      ## residual.
      element relative_error {
        real
      },
      ## The absolute error allowed to remain in the vector l2 norm of the combined systems residual upon termination
      ## of the iteration loop.
      ##
      ## Defaults to 1.e-50.
      element absolute_error {
        real
      }?,
      ## The maximum number of iterations to take in this nonlinear system loop.
      element max_iterations {
        integer
      },
      ## The minimum number of iterations to take in this nonlinear system loop.
      element min_iterations {
        integer
      }?,
      ## Options to give extra information for each iteration of the
      ## timestep. Some of those may really slow down your computation!
      element monitors {
        ## Output pvd visualization of the solution and residual at each iteration.
        ## 
        ## WARNING: This will produce a lot of output so should only be used for debugging purposes!
        element visualization {
          empty
        }?,
        ## Output a diagnostic file detailing the convergence of the nonlinear system iterations.
        element convergence_file { 
          comment
        }?
      },
      (
        (
          ## Never ignore solver failures (the highly recommended default).
          ##
          ## This option tests the convergence of the nonlinear systems and terminates the simulations at the end of the next iteration 
          ## if it has failed to converge.
          ##
          ## This option does not affect the handling of convergence failures within each system solver.
          element never_ignore_solver_failures {
            comment
          }|
          ## Ignore solver failures.  Intended for debugging purposes only!
          ##
          ## **Do not use this option in any scientific simulation.**
          ##
          ## This option allows the simulation to continue even if the nonlinear systems fail to meet the convergence criteria.
          ##
          ## This option does not affect the handling of convergence failures within each system solver.
          element ignore_all_solver_failures {
            comment
          }
        )
      )
   )

solution_order = 
   (
      ## By default, TerraFERMA calls solvers in the order in which they appear in the options file: first by system and then by
      ## nonlinear_solver.
      ##
      ## The solution_order option allows this to be overridden and, additionally, allows nonlinearities between systems to be
      ## iteratively accounted for (to some specified tolerance).
      ##
      ## Three solve locations are currently implemented in TerraFERMA: at_start, in_timeloop and with_diagnostics.  Activating a
      ## solution_order option here for any of these will over-ride the solve location designation described under the nonlinear_solver
      ## itself.
      element solution_order {
        ## Activate this option to over-ride the default solution order (by system and then by nonlinear_solver) at the start of the
        ## simulation.  Note that this will ignore the solve::at_start option underneath the nonlinear_solver itself.
        ## Once activated here, nonlinear_solvers with a solve::at_start option must be explicitly listed here to actually be
        ## solved.
        element solve {
          attribute name { "at_start" },
          nonlinear_solver_step+,
          nonlinear_coupled?,
          comment
        }?,
        ## Activate this option to over-ride the default solution order (by system and then by nonlinear_solver) in the timeloop of the
        ## simulation.  Note that this will ignore the solve::in_timeloop option underneath the nonlinear_solver itself.
        ## Once activated here, nonlinear_solvers with a solve::in_timeloop option must be explicitly listed here to actually be
        ## solved.
        element solve {
          attribute name { "in_timeloop" },
          nonlinear_solver_step+,
          nonlinear_coupled?,
          comment
        }?,
        ## Activate this option to over-ride the default solution order (by system and then by nonlinear_solver) with the diagnostics of the
        ## simulation.  Note that this will ignore the solve::with_diagnostics option underneath the nonlinear_solver itself.
        ## Once activated here, nonlinear_solvers with a solve::with_diagnostics option must be explicitly listed here to actually be
        ## solved.
        element solve {
          attribute name { "with_diagnostics" },
          nonlinear_solver_step+,
          nonlinear_coupled?,
          comment
        }?
      }
   )

nonlinear_coupled = 
   (
      ## Sometime an individual system or nonlinear_solver needs to be solved outside of the standard solve locations.  For example,
      ## when updating the timestep or when some systems request diagnostic output but others don't.
      ##
      ## On these occasions the individual non_linear solvers here are, by default, assumed not to be coupled together.  Turning on
      ## these options forces all the solvers to be solved together always, incorporating any (one-way) dependencies between successive
      ## systems.
      ## 
      ## This does not affect the solution order in the timeloop or at the start of the simulation where all solvers are always
      ## solved in the solution order specified here.
      element coupled {
        comment
      }
   )

nonlinear_solver_step =
   (
      ## Specify the solver to be solved here.
      ##
      ## This can either be a reference to a nonlinear_solver in a system or a new nonlinear systems solver that iterates over
      ## multiple nonlinear_solvers to converge nonlinearities between systems.
      element solver {
        attribute name { xsd:string },
        (
          ## Choose the type of the solver.
          ##
          ## This can either be a reference to a nonlinear_solver in a system or a new nonlinear systems solver that iterates over
          ## multiple nonlinear_solvers to converge nonlinearities between systems.
          element type {
            attribute name { "nonlinear_solver" },
            ## The system name
            element system {
              attribute name { xsd:string },
              comment
            },
            ## The nonlinear solver name
            element nonlinear_solver {
              attribute name { xsd:string },
              comment
            }
          }|
          ## Choose the type of the solver.
          ##
          ## This can either be a reference to a nonlinear_solver in a system or a new nonlinear systems solver that iterates over
          ## multiple nonlinear_solvers to converge nonlinearities between systems.
          element type {
            attribute name { "nonlinear_systems_solver" },
            nonlinear_systems_tolerances,
            nonlinear_solver_step+,
            comment
          }
        )
      }
   )

