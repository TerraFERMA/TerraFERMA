<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="ufl.rng"/>
  <define name="nonlinear_solver_options">
    <element name="nonlinear_solver">
      <a:documentation>Options describing a nonlinear solver.  This consists of a set of bilinear and linear forms acting on the function 
and functionspace in this system and using coefficients defined anywhere in this options file.  Additionally a nonlinear
solver describes the method of convering the nonlinear solve, either using a Newton or Picard iteration loop and a
description of the linear solver used within this loop.</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="type">
          <a:documentation>The type of nonlinear solver. 
PETSc SNES - a Newton iteration with line search.</a:documentation>
          <ref name="snes"/>
        </element>
        <element name="type">
          <a:documentation>The type of nonlinear solver. 
A Picard iteration.</a:documentation>
          <ref name="picard"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="picard">
    <attribute name="name">
      <value>Picard</value>
    </attribute>
    <optional>
      <element name="preamble">
        <a:documentation>ufl code preamble to the forms defined below.  
Any system, field or coefficient ufl symbols defined in this options file may be used in this preamble.</a:documentation>
        <ref name="python_code"/>
      </element>
    </optional>
    <element name="form">
      <a:documentation>ufl code form describing a bilinear form (must return a bilinear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble above.</a:documentation>
      <attribute name="name">
        <value>Bilinear</value>
      </attribute>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="python_code"/>
      <ref name="form_ufl_symbol"/>
      <ref name="ident_zeros"/>
    </element>
    <optional>
      <element name="form">
        <a:documentation>ufl code form describing a preconditioner bilinear form (must return a bilinear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble and bilinear form above.

If undefined the bilinear form above will be used to precondition itself.</a:documentation>
        <attribute name="name">
          <value>BilinearPC</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <ref name="python_code"/>
        <ref name="form_ufl_symbol"/>
        <ref name="ident_zeros"/>
      </element>
    </optional>
    <element name="form">
      <a:documentation>ufl code form describing a linear form (must return a linear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble and bilinear forms above.</a:documentation>
      <attribute name="name">
        <value>Linear</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="python_code"/>
      <ref name="form_ufl_symbol"/>
    </element>
    <element name="form">
      <a:documentation>ufl code form describing a linear residual form (must return a linear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble, bilinear and linear forms above.</a:documentation>
      <attribute name="name">
        <value>Residual</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="python_code">
        <a:documentation>ufl code describing a form.</a:documentation>
      </ref>
      <ref name="form_ufl_symbol"/>
    </element>
    <ref name="quadrature_degree"/>
    <element name="relative_error">
      <a:documentation>The relative error allowed to remain in the vector l2 norm of the nonlinear solver residual (defined above) upon termination
of the iteration loop.</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>The absolute error allowed to remain in the vector l2 norm of the nonlinear solver residual (defined above) upon termination
of the iteration loop.

Defaults to 1.e-50.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>The maximum number of iterations to take in this nonlinear solver loop.</a:documentation>
      <ref name="integer"/>
    </element>
    <optional>
      <element name="min_iterations">
        <a:documentation>The minimum number of iterations to take in this nonlinear solver loop.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
    <element name="monitors">
      <a:documentation>Options to give extra information for each iteration of the
the Picard solve. Some of those may really slow down your computation!</a:documentation>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a diagnostic file detailing the convergence of this solver.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="norms">
          <a:documentation>Print norms of vectors and matrices to stdout log</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
    <element name="linear_solver">
      <a:documentation>Options describing a linear solver.</a:documentation>
      <ref name="linear_solver_options_picard_top"/>
      <element name="monitors">
        <a:documentation>Options to give extra information for the linear solver.</a:documentation>
        <optional>
          <element name="view_ksp">
            <a:documentation>Prints PETSc information about the ksp object.</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
    </element>
    <ref name="solver_failures"/>
  </define>
  <define name="snes">
    <attribute name="name">
      <value>SNES</value>
    </attribute>
    <optional>
      <element name="preamble">
        <a:documentation>ufl code preamble to the forms defined below.  
Any system, field or coefficient ufl symbols defined in this options file may be used in this preamble.</a:documentation>
        <ref name="python_code"/>
      </element>
    </optional>
    <element name="form">
      <a:documentation>ufl code form describing a linear residual form (must return a linear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble above.</a:documentation>
      <attribute name="name">
        <value>Residual</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="python_code"/>
      <ref name="form_ufl_symbol"/>
    </element>
    <element name="form">
      <a:documentation>ufl code form describing a jacobian bilinear form (must return a bilinear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble and residual linear form above.</a:documentation>
      <attribute name="name">
        <value>Jacobian</value>
      </attribute>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="python_code"/>
      <ref name="form_ufl_symbol"/>
      <ref name="ident_zeros"/>
    </element>
    <optional>
      <element name="form">
        <a:documentation>ufl code form describing a preconditioner jacobian bilinear form (must return a bilinear form).  
Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
defined in the preamble and bilinear form above.

If undefined the jacobian bilinear form above will be used to precondition itself.</a:documentation>
        <attribute name="name">
          <value>JacobianPC</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <ref name="python_code"/>
        <ref name="form_ufl_symbol"/>
        <ref name="ident_zeros"/>
      </element>
    </optional>
    <ref name="quadrature_degree"/>
    <choice>
      <element name="snes_type">
        <a:documentation>The SNES type.  Line search.</a:documentation>
        <attribute name="name">
          <value>ls</value>
        </attribute>
        <choice>
          <element name="ls_type">
            <a:documentation>Performs a cubic line search (default line search method).</a:documentation>
            <attribute name="name">
              <value>cubic</value>
            </attribute>
            <empty/>
          </element>
          <element name="ls_type">
            <a:documentation>Performs a quadratic line search.</a:documentation>
            <attribute name="name">
              <value>quadratic</value>
            </attribute>
            <empty/>
          </element>
          <element name="ls_type">
            <a:documentation>This routine is not a line search at all; it simply uses the full Newton step.  
Thus, this routine is intended to serve as a template and is not recommended for general use.</a:documentation>
            <attribute name="name">
              <value>basic</value>
            </attribute>
            <empty/>
          </element>
          <element name="ls_type">
            <a:documentation>This routine is not a line search at all; it simply uses the full Newton step.  
This version does not even compute the norm of the function or search direction; 
this is intended only when you know the full step is fine and are not checking for 
convergence of the nonlinear iteration (for example, you are running always for a 
fixed number of Newton steps).</a:documentation>
            <attribute name="name">
              <value>basicnonorms</value>
            </attribute>
            <empty/>
          </element>
        </choice>
        <optional>
          <element name="alpha">
            <a:documentation>The scalar such that .5*f_{n+1} . f_{n+1} &lt;= .5*f_n . f_n - alpha |p_n . J . f_n|.

We are finding the zero of f() so the one dimensional minimization problem we are 
solving in the line search is minimize .5*f(x_n + lambda*step_direction) . f(x_n + lambda*step_direction)

Defaults to 1.e-4 if unset.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="max_step">
            <a:documentation>The maximum norm of the update vector.

We are finding the zero of f() so the one dimensional minimization problem we are 
solving in the line search is minimize .5*f(x_n + lambda*step_direction) . f(x_n + lambda*step_direction)

Defaults to 1.e8 if unset.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="min_lambda">
            <a:documentation>lambda is not allowed to be smaller than minlambda/( max_i y[i]/x[i]).

We are finding the zero of f() so the one dimensional minimization problem we are 
solving in the line search is minimize .5*f(x_n + lambda*step_direction) . f(x_n + lambda*step_direction)

NOTE: setting this parameter is only available when using PETSc &gt;= 3.2, it will error with older versions.

Defaults to 1.e-12 if unset.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="snes_type">
        <a:documentation>The SNES type. Variational Inequality.

NOTE: only available with Petsc &gt;= 3.2.</a:documentation>
        <attribute name="name">
          <value>vi</value>
        </attribute>
        <element name="constraints">
          <a:documentation>Place constraints on the variational inequality.</a:documentation>
          <optional>
            <element name="upper_bound">
              <a:documentation>Describe the upper bound constraint on fields.</a:documentation>
              <ref name="is_constraints"/>
            </element>
          </optional>
          <optional>
            <element name="lower_bound">
              <a:documentation>Describe the upper bound constraint on fields.</a:documentation>
              <ref name="is_constraints"/>
            </element>
          </optional>
        </element>
      </element>
      <element name="snes_type">
        <a:documentation>The SNES type.</a:documentation>
        <attribute name="name">
          <value>tr</value>
        </attribute>
        <empty/>
      </element>
      <element name="snes_type">
        <a:documentation>The SNES type.</a:documentation>
        <attribute name="name">
          <value>python</value>
        </attribute>
        <empty/>
      </element>
      <element name="snes_type">
        <a:documentation>The SNES type.</a:documentation>
        <attribute name="name">
          <value>test</value>
        </attribute>
        <empty/>
      </element>
      <element name="snes_type">
        <a:documentation>The SNES type.  Any valid PETSc SNES type may be entered.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <empty/>
      </element>
    </choice>
    <element name="relative_error">
      <a:documentation>The relative error allowed to remain in the l2 norm of the nonlinear solver residual upon termination
of the iteration loop.</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>The absolute error allowed to remain in the vector l2 norm of the nonlinear solver residual upon termination
of the iteration loop.

Defaults to 1.e-50.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <optional>
      <element name="solution_error">
        <a:documentation>Defaults to 1.e-8.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>The maximum number of iterations to take in this nonlinear solver loop.</a:documentation>
      <ref name="integer"/>
    </element>
    <optional>
      <element name="max_function_evaluations">
        <a:documentation>The maximum number of solver evaluations allowed in this nonlinear solver loop.

Defaults to 10000.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
    <element name="monitors">
      <a:documentation>Options to give extra information for each iteration of the
the SNES solve. Some of those may really slow down your computation!</a:documentation>
      <optional>
        <element name="view_snes">
          <a:documentation>Prints PETSc information about the snes object.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="residual">
          <a:documentation>Output the residual at every function evaluation.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="solution_graph">
          <a:documentation>Plot a graph of the solution with each iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a diagnostic file detailing the convergence of this solver.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="norms">
          <a:documentation>Print norms of vectors and matrices to stdout log</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
    <element name="linear_solver">
      <a:documentation>Options describing a linear solver.</a:documentation>
      <ref name="linear_solver_options_snes_top"/>
    </element>
    <ref name="solver_failures"/>
  </define>
  <define name="ident_zeros">
    <optional>
      <element name="ident_zeros">
        <a:documentation>If this rank 1 form has zero rows, then place a 1. of the diagonal.</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="is_field">
    <element name="field">
      <a:documentation>Field to include in this index set.</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="is_field_components"/>
    </element>
  </define>
  <define name="is_field_null">
    <element name="field">
      <a:documentation>Field to include in this index set.</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="is_field_components"/>
      <choice>
        <element name="constant">
          <a:documentation>This part of the null space is constant.</a:documentation>
          <!-- A hardcoded real value -->
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <value>1.0</value>
          </element>
        </element>
        <element name="python">
          <a:documentation>Python function describing the null space for this field or component of this field.

Functions may only depend on space and should be of the form:

 def val(x):
    # Function code
    return # Return value

or:

 def val(x):
    # Function code
    return [..., ...] # Return value array

The return value must have the same length as the number of components described above for this field.

The resulting null space will be normalized automatically.</a:documentation>
          <ref name="python_code"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="is_field_constraints">
    <element name="field">
      <a:documentation>Field to include in this index set.</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="is_field_components"/>
      <choice>
        <element name="constant">
          <a:documentation>This part of the constraint is constant.

Note if this part of the constraint has multiple components then all will be set to this scalar value.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="python">
          <a:documentation>Python function describing the constraints for this field or component of this field.

Functions may only depend on space and should be of the form:

 def val(x):
    # Function code
    return # Return value

or:

 def val(x):
    # Function code
    return [..., ...] # Return value array

The return value must have the same length as the number of components described above for this field.</a:documentation>
          <ref name="python_code"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="is_field_components">
    <optional>
      <element name="components">
        <a:documentation>If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).

Defaults to all components if not selected.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="region_ids">
        <a:documentation>A list of the region ids (physical ids in gmsh).

Defaults to the whole mesh if left unspecified.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh).

If left unspecified, defaults to the whole boundary of the above region(s) (if specified) or the whole mesh (if region_ids are not specified).</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="is_monitor">
    <element name="monitors">
      <optional>
        <element name="view_index_set">
          <a:documentation>Prints PETSc information about the index set describing this index set.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="is_fieldsplit">
    <zeroOrMore>
      <ref name="is_field"/>
    </zeroOrMore>
    <ref name="is_monitor"/>
  </define>
  <define name="is_null_space">
    <zeroOrMore>
      <ref name="is_field_null"/>
    </zeroOrMore>
    <ref name="is_monitor"/>
  </define>
  <define name="is_constraints">
    <oneOrMore>
      <ref name="is_field_constraints"/>
    </oneOrMore>
    <ref name="is_monitor"/>
  </define>
  <define name="pc_options_picard">
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcfieldsplit_options_picard"/>
      <ref name="pcilu_options"/>
      <ref name="pclu_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcjacobi_options"/>
      <ref name="pcbjacobi_options"/>
      <ref name="pcasm_options"/>
      <ref name="pcksp_options_picard"/>
      <ref name="pcnone_options"/>
      <ref name="pcother_options"/>
    </choice>
  </define>
  <define name="pc_options_snes">
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcfieldsplit_options_snes"/>
      <ref name="pcilu_options"/>
      <ref name="pclu_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcjacobi_options"/>
      <ref name="pcbjacobi_options"/>
      <ref name="pcasm_options"/>
      <ref name="pcksp_options_snes"/>
      <ref name="pcnone_options"/>
      <ref name="pcother_options"/>
    </choice>
  </define>
  <define name="linear_solver_options_picard_top">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.</a:documentation>
      <ref name="kspgmres_options_picard_top"/>
      <ref name="kspfgmres_options_picard_top"/>
      <ref name="kspcg_options_picard_top"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options_picard_top"/>
      <ref name="kspother_options_picard_top"/>
    </choice>
    <ref name="pc_options_picard"/>
    <ref name="generic_solver_options"/>
  </define>
  <define name="linear_solver_options_snes_top">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.</a:documentation>
      <ref name="kspgmres_options_snes_top"/>
      <ref name="kspfgmres_options_snes_top"/>
      <ref name="kspcg_options_snes_top"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options_snes_top"/>
      <ref name="kspother_options_snes_top"/>
    </choice>
    <ref name="pc_options_snes"/>
    <ref name="generic_solver_options"/>
  </define>
  <define name="linear_solver_options_picard">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.</a:documentation>
      <ref name="kspgmres_options_picard"/>
      <ref name="kspfgmres_options_picard"/>
      <ref name="kspcg_options_picard"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options_picard"/>
      <ref name="kspother_options_picard"/>
    </choice>
    <ref name="pc_options_picard"/>
    <ref name="generic_solver_options"/>
  </define>
  <define name="linear_solver_options_snes">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.</a:documentation>
      <ref name="kspgmres_options_snes"/>
      <ref name="kspfgmres_options_snes"/>
      <ref name="kspcg_options_snes"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options_snes"/>
      <ref name="kspother_options_snes"/>
    </choice>
    <ref name="pc_options_snes"/>
    <ref name="generic_solver_options"/>
  </define>
  <define name="solver_failures">
    <choice>
      <element name="never_ignore_solver_failures">
        <empty/>
      </element>
      <element name="ignore_all_solver_failures">
        <empty/>
      </element>
    </choice>
  </define>
  <!--
    ####################################################################
    
    options for the different iterative ksp methods
    
    ####################################################################
  -->
  <define name="kspgmres_options_picard_top">
    <element name="iterative_method">
      <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
      <attribute name="name">
        <value>gmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_picard_top"/>
    </element>
  </define>
  <define name="kspfgmres_options_picard_top">
    <element name="iterative_method">
      <a:documentation>FGMRES</a:documentation>
      <attribute name="name">
        <value>fgmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for fgmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_picard_top"/>
    </element>
  </define>
  <define name="kspcg_options_picard_top">
    <element name="iterative_method">
      <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
      <attribute name="name">
        <value>cg</value>
      </attribute>
      <ref name="iterative_solver_options_picard_top"/>
    </element>
  </define>
  <define name="ksprichardson_options_picard_top">
    <element name="iterative_method">
      <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
      <attribute name="name">
        <value>richardson</value>
      </attribute>
      <ref name="iterative_solver_options_picard_top"/>
    </element>
  </define>
  <define name="kspother_options_picard_top">
    <element name="iterative_method">
      <a:documentation>Other methods

Any method provided by the PETSc library
http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="iterative_solver_options_picard_top"/>
    </element>
  </define>
  <define name="kspgmres_options_snes_top">
    <element name="iterative_method">
      <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
      <attribute name="name">
        <value>gmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_snes_top"/>
    </element>
  </define>
  <define name="kspfgmres_options_snes_top">
    <element name="iterative_method">
      <a:documentation>FGMRES</a:documentation>
      <attribute name="name">
        <value>fgmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for fgmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_snes_top"/>
    </element>
  </define>
  <define name="kspcg_options_snes_top">
    <element name="iterative_method">
      <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
      <attribute name="name">
        <value>cg</value>
      </attribute>
      <ref name="iterative_solver_options_snes_top"/>
    </element>
  </define>
  <define name="ksprichardson_options_snes_top">
    <element name="iterative_method">
      <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
      <attribute name="name">
        <value>richardson</value>
      </attribute>
      <ref name="iterative_solver_options_snes_top"/>
    </element>
  </define>
  <define name="kspother_options_snes_top">
    <element name="iterative_method">
      <a:documentation>Other methods

Any method provided by the PETSc library
http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="iterative_solver_options_snes_top"/>
    </element>
  </define>
  <define name="kspgmres_options_picard">
    <element name="iterative_method">
      <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
      <attribute name="name">
        <value>gmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_picard"/>
    </element>
  </define>
  <define name="kspfgmres_options_picard">
    <element name="iterative_method">
      <a:documentation>FGMRES</a:documentation>
      <attribute name="name">
        <value>fgmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for fgmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_picard"/>
    </element>
  </define>
  <define name="kspcg_options_picard">
    <element name="iterative_method">
      <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
      <attribute name="name">
        <value>cg</value>
      </attribute>
      <ref name="iterative_solver_options_picard"/>
    </element>
  </define>
  <define name="ksprichardson_options_picard">
    <element name="iterative_method">
      <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
      <attribute name="name">
        <value>richardson</value>
      </attribute>
      <ref name="iterative_solver_options_picard"/>
    </element>
  </define>
  <define name="kspother_options_picard">
    <element name="iterative_method">
      <a:documentation>Other methods

Any method provided by the PETSc library
http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="iterative_solver_options_picard"/>
    </element>
  </define>
  <define name="kspgmres_options_snes">
    <element name="iterative_method">
      <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
      <attribute name="name">
        <value>gmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_snes"/>
    </element>
  </define>
  <define name="kspfgmres_options_snes">
    <element name="iterative_method">
      <a:documentation>FGMRES</a:documentation>
      <attribute name="name">
        <value>fgmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for fgmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options_snes"/>
    </element>
  </define>
  <define name="kspcg_options_snes">
    <element name="iterative_method">
      <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
      <attribute name="name">
        <value>cg</value>
      </attribute>
      <ref name="iterative_solver_options_snes"/>
    </element>
  </define>
  <define name="ksprichardson_options_snes">
    <element name="iterative_method">
      <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
      <attribute name="name">
        <value>richardson</value>
      </attribute>
      <ref name="iterative_solver_options_snes"/>
    </element>
  </define>
  <define name="kspother_options_snes">
    <element name="iterative_method">
      <a:documentation>Other methods

Any method provided by the PETSc library
http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="iterative_solver_options_snes"/>
    </element>
  </define>
  <define name="ksppreonly_options">
    <element name="iterative_method">
      <a:documentation>Direct method

This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
      <attribute name="name">
        <value>preonly</value>
      </attribute>
    </element>
  </define>
  <!--
    ####################################################################
    
    options for the different preconditioners
    
    ####################################################################
  -->
  <define name="pcsor_options">
    <element name="preconditioner">
      <a:documentation>Succesive Over-Relaxation

This includes SSOR (symmetric sor)</a:documentation>
      <attribute name="name">
        <value>sor</value>
      </attribute>
    </element>
  </define>
  <define name="pceisenstat_options">
    <element name="preconditioner">
      <a:documentation>The Eisenstat method

This preconditioner is equivalent to SOR but only uses
half the number of flops,
i.e. same convergence rate but twice as fast per
iteration. Because it computes
a different preconditioned residual the convergence in
practice may be quite different though.</a:documentation>
      <attribute name="name">
        <value>eisenstat</value>
      </attribute>
    </element>
  </define>
  <define name="pcilu_options">
    <element name="preconditioner">
      <a:documentation>Incomplete LU decomposition</a:documentation>
      <attribute name="name">
        <value>ilu</value>
      </attribute>
    </element>
  </define>
  <define name="pcicc_options">
    <element name="preconditioner">
      <a:documentation>Incomplete Cholesky decomposition (only works for symmetric matrices)</a:documentation>
      <attribute name="name">
        <value>icc</value>
      </attribute>
    </element>
  </define>
  <define name="pclu_options">
    <element name="preconditioner">
      <a:documentation>LU direct solver

This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
      <attribute name="name">
        <value>lu</value>
      </attribute>
      <choice>
        <element name="factorization_package">
          <a:documentation>Package to use for the factorization - umfpack.

Useful for systems with a near zero pivot.</a:documentation>
          <attribute name="name">
            <value>umfpack</value>
          </attribute>
          <empty/>
        </element>
        <element name="factorization_package">
          <a:documentation>Package to use for the factorization - mumps.

Useful for parallel direct solves (if installed on system).</a:documentation>
          <attribute name="name">
            <value>mumps</value>
          </attribute>
          <empty/>
        </element>
        <element name="factorization_package">
          <a:documentation>Package to use for the factorization - petsc.</a:documentation>
          <attribute name="name">
            <value>petsc</value>
          </attribute>
          <empty/>
        </element>
        <element name="factorization_package">
          <a:documentation>Package to use for the factorization - any valid package.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
  <define name="pcprometheus_options">
    <element name="preconditioner">
      <a:documentation>Prometheus multigrid method</a:documentation>
      <attribute name="name">
        <value>prometheus</value>
      </attribute>
    </element>
  </define>
  <define name="pchypre_options">
    <element name="preconditioner">
      <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
      <attribute name="name">
        <value>hypre</value>
      </attribute>
      <choice>
        <element name="hypre_type">
          <a:documentation>BoomerAMG multigrid method</a:documentation>
          <attribute name="name">
            <value>boomeramg</value>
          </attribute>
        </element>
        <element name="hypre_type">
          <a:documentation>Other Hypre preconditioners</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="pcjacobi_options">
    <element name="preconditioner">
      <a:documentation>Jacobi</a:documentation>
      <attribute name="name">
        <value>jacobi</value>
      </attribute>
      <empty/>
    </element>
  </define>
  <define name="pcbjacobi_options">
    <element name="preconditioner">
      <a:documentation>Block Jacobi

This option is for parallel runs. A preconditioner is applied
locally within each domain. This means within the domain you can
choose whatever preconditioner you would choose in serial. Because
there is no coupling between the domains in the preconditioning
the performance may be less than in serial and degrade with 
increasing number of processors/decreasing local domain size.</a:documentation>
      <attribute name="name">
        <value>bjacobi</value>
      </attribute>
      <ref name="subpc_options"/>
    </element>
  </define>
  <define name="pcasm_options">
    <element name="preconditioner">
      <a:documentation>Additive Schwartz Method

This option is for parallel runs. A preconditioner is applied
locally within each domain (like bjacobi) only the local domains
are extended a bit to overlap. This increases the coupling between
the domain and thus improves the convergence. This does of course
increase the communication cost, so iterations may be more expensive
than with bjacobi.</a:documentation>
      <attribute name="name">
        <value>asm</value>
      </attribute>
      <ref name="subpc_options"/>
    </element>
  </define>
  <define name="pcnone_options">
    <element name="preconditioner">
      <a:documentation>No preconditioner</a:documentation>
      <attribute name="name">
        <value>none</value>
      </attribute>
    </element>
  </define>
  <!-- sub preconditioner to choose for bjacobi or asm -->
  <define name="subpc_options">
    <choice>
      <a:documentation>Preconditioner to apply within the local domains</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcilu_options"/>
      <ref name="pcicc_options"/>
      <ref name="pclu_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcother_options"/>
    </choice>
  </define>
  <define name="pcother_options">
    <element name="preconditioner">
      <a:documentation>Other preconditioners

Any preconditioner provided by the PETSc library
http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCType.html
(available preconditioners may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string" datatypeLibrary=""/>
      </attribute>
    </element>
  </define>
  <define name="pcksp_options_picard">
    <element name="preconditioner">
      <a:documentation>A ksp preconditioner.

This only makes sense for solves where a different approximated preconditioner
matrix is provided.

NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
solve you either need to set your tolerances much stricter for it
than in the outer solve (so that the preconditioner is close to an
exact matrix inversion), or use fgmres in the outer solve.</a:documentation>
      <attribute name="name">
        <value>ksp</value>
      </attribute>
      <element name="linear_solver">
        <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
        <ref name="linear_solver_options_picard"/>
      </element>
    </element>
  </define>
  <define name="pcksp_options_snes">
    <element name="preconditioner">
      <a:documentation>A ksp preconditioner.

This only makes sense for solves where a different approximated preconditioner
matrix is provided.

NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
solve you either need to set your tolerances much stricter for it
than in the outer solve (so that the preconditioner is close to an
exact matrix inversion), or use fgmres in the outer solve.</a:documentation>
      <attribute name="name">
        <value>ksp</value>
      </attribute>
      <element name="linear_solver">
        <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
        <ref name="linear_solver_options_snes"/>
      </element>
    </element>
  </define>
  <define name="pcfieldsplit_composite_types">
    <choice>
      <element name="composite_type">
        <a:documentation>Composite type of the fieldsplit preconditioner - multiplicative - update off diagonal blocks.</a:documentation>
        <attribute name="name">
          <value>multiplicative</value>
        </attribute>
        <empty/>
      </element>
      <element name="composite_type">
        <a:documentation>Composite type of the fieldsplit preconditioner - additive - do not update off diagonal blocks.</a:documentation>
        <attribute name="name">
          <value>additive</value>
        </attribute>
        <empty/>
      </element>
      <element name="composite_type">
        <a:documentation>Composite type of the fieldsplit preconditioner - symmetric_multiplicative - update off diagonal blocks.</a:documentation>
        <attribute name="name">
          <value>symmetric_multiplicative</value>
        </attribute>
        <empty/>
      </element>
      <element name="composite_type">
        <a:documentation>Composite type of the fieldsplit preconditioner - special.</a:documentation>
        <attribute name="name">
          <value>special</value>
        </attribute>
        <empty/>
      </element>
      <element name="composite_type">
        <a:documentation>Composite type of the fieldsplit preconditioner - schur.</a:documentation>
        <attribute name="name">
          <value>schur</value>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="pcfieldsplit_options_picard">
    <element name="preconditioner">
      <a:documentation>A fieldsplit preconditioner.</a:documentation>
      <attribute name="name">
        <value>fieldsplit</value>
      </attribute>
      <ref name="pcfieldsplit_composite_types"/>
      <oneOrMore>
        <element name="fieldsplit">
          <a:documentation>Describe the fieldsplits.  Names must be unique within this linear solver.

Fields not included in any parent fieldsplits will be excluded from this fieldsplit 
even if they are described below (a warning will be given).

Fields included in any sibling fieldsplits will be excluded from this fieldsplit
even if they are described below (a warning will be given).</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="is_fieldsplit"/>
          <element name="linear_solver">
            <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
            <ref name="linear_solver_options_picard"/>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <define name="pcfieldsplit_options_snes">
    <element name="preconditioner">
      <a:documentation>A fieldsplit preconditioner.</a:documentation>
      <attribute name="name">
        <value>fieldsplit</value>
      </attribute>
      <ref name="pcfieldsplit_composite_types"/>
      <oneOrMore>
        <element name="fieldsplit">
          <a:documentation>Describe the fieldsplits.  Names must be unique within this linear solver.

Fields not included in any parent fieldsplits will be excluded from this fieldsplit 
even if they are described below (a warning will be given).

Fields included in any sibling fieldsplits will be excluded from this fieldsplit
even if they are described below (a warning will be given).</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="is_fieldsplit"/>
          <element name="linear_solver">
            <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
            <ref name="linear_solver_options_snes"/>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <!--
    ####################################################################
    
    all the other solver options
    
    ####################################################################
  -->
  <define name="iterative_solver_options_base">
    <element name="relative_error">
      <a:documentation>Relative error

The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
Suggested value: 1.0e-7</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>Absolute error bound

The solver finishes if the preconditioned error becomes smaller than this value.

Defaults to 1.e-50.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <optional>
      <element name="divergence_error">
        <a:documentation>Divergence error bound

The solver finishes if the solutions diverge by more than this value.

Defaults to 10000.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>Maximum number of iterations allowed in the linear solver
before giving up.</a:documentation>
      <ref name="integer"/>
    </element>
  </define>
  <define name="iterative_solver_zero_initial_guess">
    <element name="zero_initial_guess">
      <a:documentation>Zero the initial guess.

NOTE: some solvers always start at zero in which case this switch will have no effect.  
Also the value of this switch on any parent solves may effect its behaviour.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="iterative_solver_nonzero_initial_guess">
    <element name="nonzero_initial_guess">
      <a:documentation>Use an initial guess from the previous solver or initial condition.

NOTE: some solvers always start at zero in which case this switch will have no effect.
Also the value of this switch on any parent solves may effect its behaviour.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="iterative_solver_initial_guess_picard">
    <ref name="iterative_solver_zero_initial_guess"/>
  </define>
  <define name="iterative_solver_initial_guess_picard" combine="choice">
    <ref name="iterative_solver_nonzero_initial_guess"/>
  </define>
  <define name="iterative_solver_initial_guess_snes">
    <ref name="iterative_solver_nonzero_initial_guess"/>
  </define>
  <define name="iterative_solver_initial_guess_snes" combine="choice">
    <ref name="iterative_solver_zero_initial_guess"/>
  </define>
  <define name="iterative_solver_options_picard">
    <ref name="iterative_solver_options_base"/>
  </define>
  <define name="iterative_solver_options_picard" combine="interleave">
    <ref name="iterative_monitors"/>
  </define>
  <define name="iterative_solver_options_picard" combine="interleave">
    <ref name="iterative_solver_initial_guess_picard"/>
  </define>
  <define name="iterative_solver_options_picard_top">
    <ref name="iterative_solver_options_base"/>
  </define>
  <define name="iterative_solver_options_picard_top" combine="interleave">
    <ref name="iterative_monitors_top"/>
  </define>
  <define name="iterative_solver_options_picard_top" combine="interleave">
    <ref name="iterative_solver_initial_guess_picard"/>
  </define>
  <define name="iterative_solver_options_snes">
    <ref name="iterative_solver_options_base"/>
  </define>
  <define name="iterative_solver_options_snes" combine="interleave">
    <ref name="iterative_monitors"/>
  </define>
  <define name="iterative_solver_options_snes" combine="interleave">
    <ref name="iterative_solver_initial_guess_snes"/>
  </define>
  <define name="iterative_solver_options_snes_top">
    <ref name="iterative_solver_options_base"/>
  </define>
  <define name="iterative_solver_options_snes_top" combine="interleave">
    <ref name="iterative_monitors_top"/>
  </define>
  <define name="iterative_solver_options_snes_top" combine="interleave">
    <ref name="iterative_solver_initial_guess_snes"/>
  </define>
  <define name="iterative_monitors_base">
    <optional>
      <element name="preconditioned_residual">
        <a:documentation>Prints the preconditioned residual for each iteration of the solve.
This is the error estimation PETSc uses during the solve.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="true_residual">
        <a:documentation>Prints the "true" residual for each iteration of the solve,
i.e. PETSc computes the L2-norm of r=A-bx. This may mean
PETSc has to do extra computations.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="preconditioned_residual_graph">
        <a:documentation>Draws a graph over the convergence of the preconditioned residual
during the solve. This option only works for systems where PETSc
has been linked with the X library.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="test_null_space">
        <a:documentation>Test any attached null spaces on the first iteration of the solve.</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="iterative_monitors_vis">
    <optional>
      <element name="convergence_file">
        <a:documentation>Output a diagnostic file detailing the convergence of this solver.</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="iterative_monitors">
    <element name="monitors">
      <a:documentation>Options to give extra information for each iteration of the
the solve. Some of those may really slow down your computation!</a:documentation>
      <ref name="iterative_monitors_base"/>
    </element>
  </define>
  <define name="iterative_monitors_top">
    <element name="monitors">
      <a:documentation>Options to give extra information for each iteration of the
the solve. Some of those may really slow down your computation!</a:documentation>
      <ref name="iterative_monitors_base"/>
      <ref name="iterative_monitors_vis"/>
    </element>
  </define>
  <define name="generic_solver_options">
    <optional>
      <element name="remove_null_space">
        <a:documentation>Remove Null-space from residual after applying preconditioner.</a:documentation>
        <oneOrMore>
          <element name="null_space">
            <a:documentation>Describe the null spaces.  Names must be unique within this linear solver.

Fields not included in any parent fieldsplits will be excluded from this nullspace 
even if they are described below (a warning will be given).

Nullspaces default to being constant over any fields described.  If no fields are specified
then the entire vector is assumed to contain a constant nullspace.  To describe variable
nullspaces python functions must be attached underneath the description of the field.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="is_null_space"/>
          </element>
        </oneOrMore>
        <element name="monitors">
          <optional>
            <element name="view_null_space">
              <a:documentation>Prints PETSc information about this null space</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </element>
    </optional>
  </define>
</grammar>
