<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="ufl.rng"/>
  <define name="nonlinear_solver_options">
    <choice>
      <element name="nonlinear_solver">
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <element name="type">
            <ref name="snes"/>
          </element>
          <element name="type">
            <ref name="picard"/>
          </element>
        </choice>
      </element>
      <element name="nonlinear_solver">
        <attribute name="name">
          <value>SNES</value>
        </attribute>
        <element name="type">
          <ref name="snes"/>
        </element>
      </element>
      <element name="nonlinear_solver">
        <attribute name="name">
          <value>Picard</value>
        </attribute>
        <element name="type">
          <ref name="picard"/>
        </element>
      </element>
    </choice>
  </define>
  <define name="picard">
    <attribute name="name">
      <value>Picard</value>
    </attribute>
    <optional>
      <element name="preamble">
        <ref name="ufl"/>
      </element>
    </optional>
    <element name="form">
      <attribute name="name">
        <value>Bilinear</value>
      </attribute>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="form"/>
    </element>
    <optional>
      <element name="form">
        <attribute name="name">
          <value>BilinearPC</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <ref name="form"/>
      </element>
    </optional>
    <element name="form">
      <attribute name="name">
        <value>Linear</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="form"/>
    </element>
    <element name="form">
      <attribute name="name">
        <value>Residual</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="form"/>
    </element>
    <element name="relative_error">
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <ref name="integer"/>
    </element>
    <optional>
      <element name="min_iterations">
        <ref name="integer"/>
      </element>
    </optional>
    <element name="linear_solver">
      <ref name="linear_solver_options"/>
    </element>
  </define>
  <define name="snes">
    <attribute name="name">
      <value>SNES</value>
    </attribute>
    <optional>
      <element name="preamble">
        <ref name="ufl"/>
      </element>
    </optional>
    <element name="form">
      <attribute name="name">
        <value>Residual</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="form"/>
    </element>
    <element name="form">
      <a:documentation>Describe the Jacobian form using ufl</a:documentation>
      <attribute name="name">
        <value>Jacobian</value>
      </attribute>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="form"/>
    </element>
    <optional>
      <element name="form">
        <attribute name="name">
          <value>JacobianPC</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <ref name="form"/>
      </element>
    </optional>
    <element name="relative_error">
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <ref name="real"/>
      </element>
    </optional>
    <optional>
      <element name="solution_error">
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <ref name="integer"/>
    </element>
    <optional>
      <element name="min_function_evaluations">
        <ref name="integer"/>
      </element>
    </optional>
    <element name="linear_solver">
      <ref name="linear_solver_options"/>
    </element>
  </define>
  <define name="linear_solver_options">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <ref name="kspgmres_options"/>
      <ref name="kspfgmres_options"/>
      <ref name="kspcg_options"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options"/>
      <ref name="kspother_options"/>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcfieldsplit_options"/>
      <ref name="pcilu_options"/>
      <ref name="pclu_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcbjacobi_options"/>
      <ref name="pcasm_options"/>
      <ref name="pcksp_options"/>
      <ref name="pcother_options"/>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <!--
    ####################################################################
    
    options for the different iterative ksp methods
    
    ####################################################################
  -->
  <define name="kspgmres_options">
    <element name="iterative_method">
      <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
      <attribute name="name">
        <value>gmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options"/>
    </element>
  </define>
  <define name="kspfgmres_options">
    <element name="iterative_method">
      <a:documentation>FGMRES</a:documentation>
      <attribute name="name">
        <value>fgmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for fgmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="iterative_solver_options"/>
    </element>
  </define>
  <define name="kspcg_options">
    <element name="iterative_method">
      <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
      <attribute name="name">
        <value>cg</value>
      </attribute>
      <ref name="iterative_solver_options"/>
    </element>
  </define>
  <define name="ksppreonly_options">
    <element name="iterative_method">
      <a:documentation>Direct method

This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
      <attribute name="name">
        <value>preonly</value>
      </attribute>
    </element>
  </define>
  <define name="ksprichardson_options">
    <element name="iterative_method">
      <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
      <attribute name="name">
        <value>richardson</value>
      </attribute>
      <ref name="iterative_solver_options"/>
    </element>
  </define>
  <define name="kspother_options">
    <element name="iterative_method">
      <a:documentation>Other methods

Any method provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="iterative_solver_options"/>
    </element>
  </define>
  <!--
    ####################################################################
    
    options for the different preconditioners
    
    ####################################################################
  -->
  <define name="pcsor_options">
    <element name="preconditioner">
      <a:documentation>Succesive Over-Relaxation

This includes SSOR (symmetric sor)</a:documentation>
      <attribute name="name">
        <value>sor</value>
      </attribute>
    </element>
  </define>
  <define name="pceisenstat_options">
    <element name="preconditioner">
      <a:documentation>The Eisenstat method

This preconditioner is equivalent to SOR but only uses
half the number of flops,
i.e. same convergence rate but twice as fast per
iteration. Because it computes
a different preconditioned residual the convergence in
practice may be quite different though.</a:documentation>
      <attribute name="name">
        <value>eisenstat</value>
      </attribute>
    </element>
  </define>
  <define name="pcilu_options">
    <element name="preconditioner">
      <a:documentation>Incomplete LU decomposition</a:documentation>
      <attribute name="name">
        <value>ilu</value>
      </attribute>
    </element>
  </define>
  <define name="pcicc_options">
    <element name="preconditioner">
      <a:documentation>Incomplete Cholesky decomposition (only works for symmetric matrices)</a:documentation>
      <attribute name="name">
        <value>icc</value>
      </attribute>
    </element>
  </define>
  <define name="pclu_options">
    <element name="preconditioner">
      <a:documentation>LU direct solver

This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
      <attribute name="name">
        <value>lu</value>
      </attribute>
    </element>
  </define>
  <define name="pcprometheus_options">
    <element name="preconditioner">
      <a:documentation>Prometheus multigrid method</a:documentation>
      <attribute name="name">
        <value>prometheus</value>
      </attribute>
    </element>
  </define>
  <define name="pchypre_options">
    <element name="preconditioner">
      <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
      <attribute name="name">
        <value>hypre</value>
      </attribute>
      <choice>
        <element name="hypre_type">
          <a:documentation>BoomerAMG multigrid method</a:documentation>
          <attribute name="name">
            <value>boomeramg</value>
          </attribute>
        </element>
        <element name="hypre_type">
          <a:documentation>Other Hypre preconditioners</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="pcbjacobi_options">
    <element name="preconditioner">
      <a:documentation>Block Jacobi

This option is for parallel runs. A preconditioner is applied
locally within each domain. This means within the domain you can
choose whatever preconditioner you would choose in serial. Because
there is no coupling between the domains in the preconditioning
the performance may be less than in serial and degrade with 
increasing number of processors/decreasing local domain size.</a:documentation>
      <attribute name="name">
        <value>bjacobi</value>
      </attribute>
      <ref name="subpc_options"/>
    </element>
  </define>
  <define name="pcasm_options">
    <element name="preconditioner">
      <a:documentation>Additive Schwartz Method

This option is for parallel runs. A preconditioner is applied
locally within each domain (like bjacobi) only the local domains
are extended a bit to overlap. This increases the coupling between
the domain and thus improves the convergence. This does of course
increase the communication cost, so iterations may be more expensive
than with bjacobi.</a:documentation>
      <attribute name="name">
        <value>asm</value>
      </attribute>
      <ref name="subpc_options"/>
    </element>
  </define>
  <!-- sub preconditioner to choose for bjacobi or asm -->
  <define name="subpc_options">
    <choice>
      <a:documentation>Preconditioner to apply within the local domains</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcilu_options"/>
      <ref name="pcicc_options"/>
      <ref name="pclu_options"/>
      <ref name="pcmg_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcother_options"/>
    </choice>
  </define>
  <define name="pcother_options">
    <element name="preconditioner">
      <a:documentation>Other preconditioners

Any preconditioner provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
(available preconditiors may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string" datatypeLibrary=""/>
      </attribute>
    </element>
  </define>
  <define name="pcksp_options">
    <element name="preconditioner">
      <a:documentation>This only makes sense for solves where a different approximated preconditioner
matrix is provided.

NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
solve you either need to set your tolerances much stricter for it
than in the outer solve (so that the preconditioner is close to an
exact matrix inversion), or use fgmres in the outer solve.</a:documentation>
      <attribute name="name">
        <value>ksp</value>
      </attribute>
      <element name="linear_solver">
        <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
        <ref name="linear_solver_options"/>
      </element>
    </element>
  </define>
  <define name="pcfieldsplit_options">
    <element name="preconditioner">
      <attribute name="name">
        <value>fieldsplit</value>
      </attribute>
      <choice>
        <element name="composite_type">
          <attribute name="name">
            <value>additive</value>
          </attribute>
          <empty/>
        </element>
        <element name="composite_type">
          <attribute name="name">
            <value>multiplicative</value>
          </attribute>
          <empty/>
        </element>
        <element name="composite_type">
          <attribute name="name">
            <value>symmetric_multiplicative</value>
          </attribute>
          <empty/>
        </element>
        <element name="composite_type">
          <attribute name="name">
            <value>special</value>
          </attribute>
          <empty/>
        </element>
        <element name="composite_type">
          <attribute name="name">
            <value>schur</value>
          </attribute>
          <empty/>
        </element>
      </choice>
      <oneOrMore>
        <element name="fieldsplit">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <oneOrMore>
            <element name="field">
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <optional>
                <element name="components">
                  <a:documentation>If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).

Defaults to all components if not selected.</a:documentation>
                  <ref name="integer_vector"/>
                </element>
              </optional>
              <optional>
                <element name="region_ids">
                  <a:documentation>A list of the region ids (physical ids in gmsh) </a:documentation>
                  <ref name="integer_vector"/>
                </element>
              </optional>
            </element>
          </oneOrMore>
          <element name="linear_solver">
            <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
            <ref name="linear_solver_options"/>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <!--
    ####################################################################
    
    all the other solver options
    
    ####################################################################
  -->
  <define name="iterative_solver_options">
    <element name="relative_error">
      <a:documentation>Relative error

The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
Suggested value: 1.0e-7</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>Absolute error bound

The solver finishes if the preconditioned error becomes smaller than this value.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <optional>
      <element name="absolute_error">
        <a:documentation>Divergence error bound

The solver finishes if the solutions diverge by more than this value.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>Maximum number of iterations allowed in the linear solver
before giving up.</a:documentation>
      <ref name="integer"/>
    </element>
  </define>
  <define name="generic_solver_options">
    <optional>
      <element name="start_from_zero">
        <a:documentation>Switch on to not use an initial guess from a previous solve but
start with a zero vector. Note that some of the solves always
start at zero in which case this switch will have no effect (see the log output).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="remove_null_space">
        <a:documentation>Remove Null-space from residual after applying preconditioner.
This often leads to better convergence rates, when compared to
imposing a reference_node to pin the solution.</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
</grammar>
