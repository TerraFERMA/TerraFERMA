# Copyright (C) 2013 Columbia University in the City of New York and others.
#
# Please see the AUTHORS file in the main source directory for a full list
# of contributors.
#
# This file is part of TerraFERMA.
#
# TerraFERMA is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TerraFERMA is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with TerraFERMA. If not, see <http://www.gnu.org/licenses/>.

include "spud_base.rnc"
include "ufl.rnc"

nonlinear_solver_options =
  (
    ## Options describing a nonlinear solver.  This consists of a set of bilinear and linear forms acting on the function 
    ## and functionspace in this system and using coefficients defined anywhere in this options file.  Additionally a nonlinear
    ## solver describes the method of convering the nonlinear solve, either using a Newton or Picard iteration loop and a
    ## description of the linear solver used within this loop.
    element nonlinear_solver {
      attribute name { xsd:string },
      (
        ## The type of nonlinear solver. 
        ## PETSc SNES - a Newton iteration with line search.
        element type {
          snes
        }|
        ## The type of nonlinear solver. 
        ## A Picard iteration.
        element type {
          picard
        }
      ),
      solve_location,
      comment
    }
  )

picard =
  (
    attribute name { "Picard" },
    ## ufl code preamble to the forms defined below.  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this preamble.
    element preamble {
      python3_code 
    }?,
    ## ufl code form describing a bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble above.
    element form {
      attribute name { "Bilinear" },
      attribute rank { "1" },
      python3_code,
      form_ufl_symbol,
      ident_zeros
    },
    ## ufl code form describing a preconditioner bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and bilinear form above.
    ##
    ## If undefined the bilinear form above will be used to precondition itself.
    element form {
      attribute name { "BilinearPC" },
      attribute rank { "1" },
      python3_code,
      form_ufl_symbol,
      ident_zeros
    }?,
    ## ufl code form describing a linear form (must return a linear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and bilinear forms above.
    element form {
      attribute name { "Linear" },
      attribute rank { "0" },
      python3_code,
      form_ufl_symbol
    },
    ## ufl code form describing a linear residual form (must return a linear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble, bilinear and linear forms above.
    element form {
      attribute name { "Residual" },
      attribute rank { "0" },
      ## ufl code describing a form.
      python3_code,
      form_ufl_symbol
    },
    form_representation,
    quadrature_degree,
    quadrature_rule,
    ## The relative error allowed to remain in the vector l2 norm of the nonlinear solver residual (defined above) upon termination
    ## of the iteration loop.
    element relative_error {
      real
    },
    ## The absolute error allowed to remain in the vector l2 norm of the nonlinear solver residual (defined above) upon termination
    ## of the iteration loop.
    ##
    ## Defaults to 1.e-50.
    element absolute_error {
      real
    }?,
    ## The maximum number of iterations to take in this nonlinear solver loop.
    element max_iterations {
      integer
    },
    ## The minimum number of iterations to take in this nonlinear solver loop.
    element min_iterations {
      integer
    }?,
    ## Relaxation parameter for solution between iterations.
    ##
    ## Defaults to 1.0 (no relaxation).
    element relaxation_parameter {
      real
    }?,
    ## Options to give extra information for each iteration of the
    ## Picard solve. Some of those may really slow down your computation!
    element monitors {
       ## Output pvd visualization of the solution and residual at each iteration.
       ## 
       ## WARNING: This will produce a lot of output so should only be used for debugging purposes!
       element visualization {
          comment
       }?,
       ## Output a diagnostic file detailing the convergence of this solver.
       element convergence_file { 
         comment
       }?,
       ## Print norms of vectors and matrices to stdout log
       element norms {
          comment
       }?,
       comment
    },
    ## Options describing a linear solver.
    element linear_solver {
      linear_solver_options_picard_top,
      ## Options to give extra information for the linear solver.
      element monitors {
         ## Prints PETSc information about the ksp object.
         element view_ksp {
           comment
         }?,
         comment
      }
    },
    solver_failures,
    comment
  )

snes =
  (
    attribute name { "SNES" },
    ## ufl code preamble to the forms defined below.  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this preamble.
    element preamble {
      python3_code
    }?,
    ## ufl code form describing a linear residual form (must return a linear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble above.
    element form {
      attribute name { "Residual" },
      attribute rank { "0" },
      python3_code,
      form_ufl_symbol
    },
    ## ufl code form describing a jacobian bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and residual linear form above.
    element form {
      attribute name { "Jacobian" },
      attribute rank { "1" },
      python3_code,
      form_ufl_symbol,
      ident_zeros
    },
    ## ufl code form describing a preconditioner jacobian bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and bilinear form above.
    ##
    ## If undefined the jacobian bilinear form above will be used to precondition itself.
    element form {
      attribute name { "JacobianPC" },
      attribute rank { "1" },
      python3_code,
      form_ufl_symbol,
      ident_zeros
    }?,
    form_representation,
    quadrature_degree,
    quadrature_rule,
    (
      ## The SNES type.  Line search.
      element snes_type {
        attribute name { "ls" },
        (
          ## Performs a cubic line search (default line search method).
          element ls_type {
            attribute name { "cubic" },
            comment
          }|
          ## Performs a quadratic line search.
          element ls_type {
            attribute name { "quadratic" },
            comment
          }|
          ## This routine is not a line search at all; it simply uses the full Newton step.  
          ## Thus, this routine is intended to serve as a template and is not recommended for general use.
          element ls_type {
            attribute name { "basic" },
            comment
          }|
          ## This routine is not a line search at all; it simply uses the full Newton step.  
          ## This version does not even compute the norm of the function or search direction; 
          ## this is intended only when you know the full step is fine and are not checking for 
          ## convergence of the nonlinear iteration (for example, you are running always for a 
          ## fixed number of Newton steps).
          element ls_type {
            attribute name { "basicnonorms" },
            comment
          }
        ),
        snes_convergence_test,
        ## The scalar such that .5*f_{n+1} . f_{n+1} <= .5*f_n . f_n - alpha |p_n . J . f_n|.
        ##
        ## We are finding the zero of f() so the one dimensional minimization problem we are 
        ## solving in the line search is minimize .5*f(x_n + lambda*step_direction) . f(x_n + lambda*step_direction)
        ##
        ## Defaults to 1.e-4 if unset.
        element alpha {
          real
        }?,
        ## The maximum norm of the update vector.
        ##
        ## We are finding the zero of f() so the one dimensional minimization problem we are 
        ## solving in the line search is minimize .5*f(x_n + lambda*step_direction) . f(x_n + lambda*step_direction)
        ##
        ## Defaults to 1.e8 if unset.
        element max_step {
          real
        }?,
        ## lambda is not allowed to be smaller than minlambda/( max_i y[i]/x[i]).
        ##
        ## We are finding the zero of f() so the one dimensional minimization problem we are 
        ## solving in the line search is minimize .5*f(x_n + lambda*step_direction) . f(x_n + lambda*step_direction)
        ##
        ## NOTE: setting this parameter is only available when using PETSc >= 3.2, it will error with older versions.
        ##
        ## Defaults to 1.e-12 if unset.
        element min_lambda {
          real
        }?,
        comment
      }|
      ## The SNES type. Variational Inequality.
      ##
      ## NOTE: only available with Petsc >= 3.2 and with petsc > 3.2 this maps to virs.
      element snes_type {
        attribute name { "vi" },
        ## Place constraints on the variational inequality.
        element constraints {
           ## Describe the upper bound constraint on fields.
           element upper_bound {
             is_constraints,
             comment
           }?,
           ## Describe the upper bound constraint on fields.
           element lower_bound {
             is_constraints,
             comment
           }?,
           comment
        },
        snes_convergence_test,
        comment
      }|
      ## The SNES type.  KSP only - treat as a linear problem.
      element snes_type {
        attribute name { "ksponly" },
        comment
      }|
      ## The SNES type.  Any valid PETSc SNES type may be entered.
      element snes_type {
        attribute name { xsd:string },
        comment
      }
    ),
    ## The relative error allowed to remain in the l2 norm of the nonlinear solver residual upon termination
    ## of the iteration loop.
    element relative_error {
      real
    },
    ## The absolute error allowed to remain in the vector l2 norm of the nonlinear solver residual upon termination
    ## of the iteration loop.
    ##
    ## Defaults to 1.e-50.
    element absolute_error {
      real
    }?,
    ## Defaults to 1.e-8.
    element solution_error {
      real
    }?,
    ## The maximum number of iterations to take in this nonlinear solver loop.
    element max_iterations {
      integer
    },
    ## The maximum number of solver evaluations allowed in this nonlinear solver loop.
    ##
    ## Defaults to 10000.
    element max_function_evaluations {
      integer
    }?,
    ## Options to give extra information for each iteration of the
    ## the SNES solve. Some of those may really slow down your computation!
    element monitors {
       ## Prints PETSc information about the snes object.
       element view_snes {
         comment
       }?,
       ## Output the residual at every function evaluation.
       element residual {
         comment
       }?,
       ## Plot a graph of the solution with each iteration.
       element solution_graph {
         comment
       }?,
       ## Output pvd visualization of the solution and residual at each iteration.
       ## 
       ## WARNING: This will produce a lot of output so should only be used for debugging purposes!
       element visualization {
         comment
       }?,
       ## Output a diagnostic file detailing the convergence of this solver.
       element convergence_file { 
         comment
       }?,
       ## Print norms of vectors and matrices to stdout log
       element norms {
         comment
       }?,
       comment
    },
    ## Options describing a linear solver.
    element linear_solver {
      linear_solver_options_snes_top
    },
    solver_failures,
    comment
  )

solve_location = 
  (
    (
      ## Solve the equations listed in this nonlinear solver every timestep.
      element solve {
        attribute name {"in_timeloop"},
        comment
      }|
      ## Only solve the equations listed in this nonlinear solver at the start of the simulation.
      element solve {
        attribute name {"at_start"},
        comment
      }|
      ## Only solve the equations listed in this nonlinear solver when diagnostic output is performed.
      ##
      ## This means that this system will be updated at an interval dependant on how the diagnostic dump periods are set in /io.
      element solve {
        attribute name {"with_diagnostics"},
        comment
      }|
      ## Never solve the equations listed in this nonlinear solver.
      ##
      ## This is primarily intended to be used in checkpoint files when systems set to solve 'at_start' are never solved for in the 
      ## checkpointed simulation.
      element solve {
        attribute name {"never"},
        comment
      }
    )
  )

ident_zeros =
  (
    ## If this rank 1 form has zero rows, then place a 1. of the diagonal.
    element ident_zeros {
      comment
    }?
  )

is_field = 
  (
    ## Field to include in this index set.
    element field {
      attribute name { xsd:string },
      is_field_components,
      comment
    }
  )

is_field_null = 
  (
    ## Field to include in this index set.
    element field {
      attribute name { xsd:string },
      is_field_components,
      (
        ## This part of the null space is constant.
        element constant {
          # A hardcoded real value
          element real_value{
             attribute rank { "0" },
             ( "1.0" )
          },
          comment
        }|
        ## Python function describing the null space for this field or component of this field.
        ##
        ## Functions may only depend on space and should be of the form:
        ##
        ##     def val(x):
        ##        # Function code
        ##        return # Return value
        ##
        ## or:
        ##
        ##     def val(x):
        ##        # Function code
        ##        return [..., ...] # Return value array
        ##
        ## The return value must have the same length as the number of components described above for this field.
        ## 
        ## The resulting null space will be normalized automatically.
        element python {
          python3_code
        }
      ),
      comment
    }
  )

is_field_constraints = 
  (
    ## Field to include in this index set.
    element field {
      attribute name { xsd:string },
      is_field_components,
      (
        ## This part of the constraint is constant.
        ##
        ## Note if this part of the constraint has multiple components then all will be set to this scalar value.
        element constant {
          real
        }|
        ## Python function describing the constraints for this field or component of this field.
        ##
        ## Functions may only depend on space and should be of the form:
        ##
        ##     def val(x):
        ##        # Function code
        ##        return # Return value
        ##
        ## or:
        ##
        ##     def val(x):
        ##        # Function code
        ##        return [..., ...] # Return value array
        ##
        ## The return value must have the same length as the number of components described above for this field.
        element python {
          python3_code
        }
      ),
      comment
    }
  )

is_field_components = 
  (
    ## If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).
    ##
    ## Defaults to all components if not selected.
    element components {
      integer_vector
    }?,
    ## A list of the region ids (physical ids in gmsh).
    ##
    ## Defaults to the whole mesh if left unspecified.
    element region_ids {
      integer_vector
    }?,
    ## A list of the boundary ids (physical ids in gmsh).
    ##
    ## If left unspecified, defaults to the whole boundary of the above region(s) (if specified) or the whole mesh (if region_ids are not specified).
    element boundary_ids {
      integer_vector
    }?
  )

is_monitor =
  (
    ## Parent option for index set monitors.
    element monitors {
      ## Prints PETSc information about the index set describing this index set.
      element view_index_set {
        comment
      }?,
      comment
    }
  )

is_fieldsplit =
  (
    is_field*,
    is_monitor
  )

is_null_space =
  (
    is_field_null*,
    ## Removes the null space from the rhs after assembly.
    element remove_from_rhs {
      ## Do not remove the null space at every iteration of the solve.
      element only_remove_from_rhs {
        comment
      }?,
      comment
    }?,
    is_monitor
  )

is_near_null_space =
  (
    is_field_null*,
    is_monitor
  )

is_constraints =
  (
    is_field_constraints+,
    is_monitor
  )

pc_options_picard =
  (
    ## Preconditioner to be used in combination with the iterative method.
    (
       pcsor_options|
       pceisenstat_options|
       pcfieldsplit_options_picard|
       pcilu_options|
       pclu_options|
       pcprometheus_options|
       pchypre_options|
       pcgamg_options|
       pcml_options|
       pcjacobi_options|
       pcbjacobi_options|
       pcasm_options|
       pcksp_options_picard|
       pclsc_options|
       pcnone_options|
       pcother_options
    )
  )

pc_options_snes =
  (
    ## Preconditioner to be used in combination with the iterative method.
    (
       pcsor_options|
       pceisenstat_options|
       pcfieldsplit_options_snes|
       pcilu_options|
       pclu_options|
       pcprometheus_options|
       pchypre_options|
       pcgamg_options|
       pcml_options|
       pcjacobi_options|
       pcbjacobi_options|
       pcasm_options|
       pcksp_options_snes|
       pclsc_options|
       pcnone_options|
       pcother_options
    )
  )

linear_solver_options_picard_top =
   (
      ## Iterative (Krylov) method to solve the linear discretised equation
      ## Given are the most frequently used methods. The solution is done
      ## by the PETSc library. Many more methods are provided.
      (
         kspgmres_options_picard_top|
         kspfgmres_options_picard_top|
         kspcg_options_picard_top|
         ksppreonly_options|
         ksprichardson_options_picard_top|
         kspother_options_picard_top
      ),
      pc_options_picard,
      generic_solver_options
   )

linear_solver_options_snes_top =
   (
      ## Iterative (Krylov) method to solve the linear discretised equation
      ## Given are the most frequently used methods. The solution is done
      ## by the PETSc library. Many more methods are provided.
      (
         kspgmres_options_snes_top|
         kspfgmres_options_snes_top|
         kspcg_options_snes_top|
         ksppreonly_options|
         ksprichardson_options_snes_top|
         kspother_options_snes_top
      ),
      pc_options_snes,
      generic_solver_options
   )

linear_solver_options_picard =
   (
      ## Iterative (Krylov) method to solve the linear discretised equation
      ## Given are the most frequently used methods. The solution is done
      ## by the PETSc library. Many more methods are provided.
      (
         kspgmres_options_picard|
         kspfgmres_options_picard|
         kspcg_options_picard|
         ksppreonly_options|
         ksprichardson_options_picard|
         kspother_options_picard
      ),
      pc_options_picard,
      generic_solver_options
   )


linear_solver_options_snes =
   (
      ## Iterative (Krylov) method to solve the linear discretised equation
      ## Given are the most frequently used methods. The solution is done
      ## by the PETSc library. Many more methods are provided.
      (
         kspgmres_options_snes|
         kspfgmres_options_snes|
         kspcg_options_snes|
         ksppreonly_options|
         ksprichardson_options_snes|
         kspother_options_snes
      ),
      pc_options_snes,
      generic_solver_options
   )

solver_failures =
  (
    (
      ## Never ignore solver failures (the highly recommended default).
      ##
      ## This option tests the convergence of the nonlinear solver and terminates the simulations at the end of the next timestep 
      ## if it has failed to converge.  Note that linear solves within the nonlinear solver may still allowed to fail.
      element never_ignore_solver_failures {
        comment
      }|
      ## Ignore solver failures.  Intended for debugging purposes only!
      ##
      ## **Do not use this option in any scientific simulation.**
      ##
      ## This option allows the simulation to continue even if this nonlinear solver fails to meet the convergence criteria.
      element ignore_all_solver_failures {
        comment
      }
    )
  )

# ####################################################################
#
# options for the different iterative ksp methods
#
# ####################################################################

kspgmres_options_picard_top =
   (
      ## GMRES
      ##
      ## Your safest bet for non-symmetric systems.
      element iterative_method {
         attribute name { "gmres" },
         ## Restart value for gmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_picard_top
      }
   )
   
kspfgmres_options_picard_top =
   (
      ## FGMRES
      element iterative_method {
         attribute name { "fgmres" },
         ## Restart value for fgmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_picard_top
      }
   )
   
kspcg_options_picard_top =
   (
      ## Conjugate gradient method
      ##
      ## Only works for symmetric systems.
      element iterative_method {
         attribute name { "cg" },
         iterative_solver_options_picard_top
      }
   )

ksprichardson_options_picard_top =
   (
      ## Richardson iteration
      ##
      ## Only apply preconditioner each iteration, no krylov acceleration
      element iterative_method {
         attribute name { "richardson" },
         iterative_solver_options_picard_top
      }
   )
   
kspother_options_picard_top =
   (
      ## Other methods
      ##
      ## Any method provided by the PETSc library
      ## http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
      ## (available methods may depend on the PETSc library installed on your system)
      element iterative_method {
         attribute name { xsd:string },
         iterative_solver_options_picard_top
      }
   )
   
kspgmres_options_snes_top =
   (
      ## GMRES
      ##
      ## Your safest bet for non-symmetric systems.
      element iterative_method {
         attribute name { "gmres" },
         ## Restart value for gmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_snes_top
      }
   )
   
kspfgmres_options_snes_top =
   (
      ## FGMRES
      element iterative_method {
         attribute name { "fgmres" },
         ## Restart value for fgmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_snes_top
      }
   )
   
kspcg_options_snes_top =
   (
      ## Conjugate gradient method
      ##
      ## Only works for symmetric systems.
      element iterative_method {
         attribute name { "cg" },
         iterative_solver_options_snes_top
      }
   )

ksprichardson_options_snes_top =
   (
      ## Richardson iteration
      ##
      ## Only apply preconditioner each iteration, no krylov acceleration
      element iterative_method {
         attribute name { "richardson" },
         iterative_solver_options_snes_top
      }
   )
   
kspother_options_snes_top =
   (
      ## Other methods
      ##
      ## Any method provided by the PETSc library
      ## http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
      ## (available methods may depend on the PETSc library installed on your system)
      element iterative_method {
         attribute name { xsd:string },
         iterative_solver_options_snes_top
      }
   )
   
kspgmres_options_picard =
   (
      ## GMRES
      ##
      ## Your safest bet for non-symmetric systems.
      element iterative_method {
         attribute name { "gmres" },
         ## Restart value for gmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_picard
      }
   )
   
kspfgmres_options_picard =
   (
      ## FGMRES
      element iterative_method {
         attribute name { "fgmres" },
         ## Restart value for fgmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_picard
      }
   )
   
kspcg_options_picard =
   (
      ## Conjugate gradient method
      ##
      ## Only works for symmetric systems.
      element iterative_method {
         attribute name { "cg" },
         iterative_solver_options_picard
      }
   )

ksprichardson_options_picard =
   (
      ## Richardson iteration
      ##
      ## Only apply preconditioner each iteration, no krylov acceleration
      element iterative_method {
         attribute name { "richardson" },
         iterative_solver_options_picard
      }
   )
   
kspother_options_picard =
   (
      ## Other methods
      ##
      ## Any method provided by the PETSc library
      ## http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
      ## (available methods may depend on the PETSc library installed on your system)
      element iterative_method {
         attribute name { xsd:string },
         iterative_solver_options_picard
      }
   )
   
kspgmres_options_snes =
   (
      ## GMRES
      ##
      ## Your safest bet for non-symmetric systems.
      element iterative_method {
         attribute name { "gmres" },
         ## Restart value for gmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_snes
      }
   )
   
kspfgmres_options_snes =
   (
      ## FGMRES
      element iterative_method {
         attribute name { "fgmres" },
         ## Restart value for fgmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options_snes
      }
   )
   
kspcg_options_snes =
   (
      ## Conjugate gradient method
      ##
      ## Only works for symmetric systems.
      element iterative_method {
         attribute name { "cg" },
         iterative_solver_options_snes
      }
   )

ksprichardson_options_snes =
   (
      ## Richardson iteration
      ##
      ## Only apply preconditioner each iteration, no krylov acceleration
      element iterative_method {
         attribute name { "richardson" },
         iterative_solver_options_snes
      }
   )
   
kspother_options_snes =
   (
      ## Other methods
      ##
      ## Any method provided by the PETSc library
      ## http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html
      ## (available methods may depend on the PETSc library installed on your system)
      element iterative_method {
         attribute name { xsd:string },
         iterative_solver_options_snes
      }
   )
   
ksppreonly_options =
   (
      ## Direct method
      ##
      ## This is for non-iterative methods
      ## Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.
      element iterative_method {
         attribute name { "preonly" },
         comment
      }
   )
   
# ####################################################################
#
# options for the different preconditioners
#
# ####################################################################

pcsor_options =
   (
      ## Succesive Over-Relaxation
      ##
      ## This includes SSOR (symmetric sor)
      element preconditioner {
         attribute name { "sor" },
         comment
      }
   )
   
pceisenstat_options =
   (
      ## The Eisenstat method
      ##
      ## This preconditioner is equivalent to SOR but only uses
      ## half the number of flops,
      ## i.e. same convergence rate but twice as fast per
      ## iteration. Because it computes
      ## a different preconditioned residual the convergence in
      ## practice may be quite different though.
      element preconditioner {
         attribute name { "eisenstat" },
         comment
      }
   )
   
pcilu_options = 
   (
      ## Incomplete LU decomposition
      element preconditioner {
         attribute name { "ilu" },
         comment
      }
   )
   
pcicc_options =
   (
      ## Incomplete Cholesky decomposition (only works for symmetric matrices)
      element preconditioner {
         attribute name { "icc" },
         comment
      }
   )
   
pclu_options =
   (
      ## LU direct solver
      ##
      ## This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.
      element preconditioner {
         attribute name { "lu" },
         (
           ## Package to use for the factorization - umfpack.
           ##
           ## Useful for systems with a near zero pivot.
           element factorization_package {
             attribute name { "umfpack" },
             comment
           }|
           ## Package to use for the factorization - mumps.
           ##
           ## Useful for parallel direct solves (if installed on system).
           element factorization_package {
             attribute name { "mumps" },
             comment
           }|
           ## Package to use for the factorization - petsc.
           element factorization_package {
             attribute name { "petsc" },
             comment
           }|
           ## Package to use for the factorization - any valid package.
           element factorization_package {
             attribute name { xsd:string },
             comment
           }
         ),
         comment
     }
   )

pcprometheus_options =
   (
      ## Prometheus multigrid method
      element preconditioner {
         attribute name { "prometheus" },
         comment
      }
   )

pchypre_options =
   (
      ## Hypre preconditioners (includes boomeramg)
      element preconditioner {
         attribute name { "hypre" },
         (
            ## BoomerAMG multigrid method
            element hypre_type {
               attribute name { "boomeramg" },
               comment
            }|
            ## Other Hypre preconditioners
            element hypre_type {
               attribute name { xsd:string },
               comment
            }
         ),
         comment
      }
   )

near_null_space =
   (
     ## Set a near null-space for this preconditioner.
     element near_null_space {
        ## Describe the null spaces.  Names must be unique within this near null space setting.
        ##
        ## Fields not included in any parent fieldsplits will be excluded from this nullspace 
        ## even if they are described below (a warning will be given).
        ##
        ## Nullspaces default to being constant over any fields described.  If no fields are specified
        ## then the entire vector is assumed to contain a constant nullspace.  To describe variable
        ## nullspaces python functions must be attached underneath the description of the field.
        element null_space {
          attribute name { xsd:string },
          is_near_null_space,
          comment
        }+,
        ## Parent option for near-null-space monitors.
        element monitors {
          ## Prints PETSc information about this null space
          element view_null_space {
            comment
          }?,
          comment
        },
        comment
     }
   )

pcgamg_options =
   (
      ## The Geometric-Algrbraic MultiGrid Method
      ##
      ## NOTE: Only available with petsc > 3.2.
      element preconditioner {
         attribute name { "gamg" },
         near_null_space?,
         comment
      }
   )

pcml_options =
   (
      ## The ML MultiGrid Method
      ##
      ## NOTE: Only available if petsc is configured with ml!
      element preconditioner {
         attribute name { "ml" },
         near_null_space?,
         comment
      }
   )

pcjacobi_options =
   (
      ## Jacobi
      element preconditioner {
         attribute name { "jacobi" },
         comment
      }
   )

pcbjacobi_options =
   (
      ## Block Jacobi
      ##
      ## This option is for parallel runs. A preconditioner is applied
      ## locally within each domain. This means within the domain you can
      ## choose whatever preconditioner you would choose in serial. Because
      ## there is no coupling between the domains in the preconditioning
      ## the performance may be less than in serial and degrade with 
      ## increasing number of processors/decreasing local domain size.
      element preconditioner {
         attribute name { "bjacobi" },
         subpc_options,
         comment
      }
   )

pcasm_options =
   (
      ## Additive Schwartz Method
      ##
      ## This option is for parallel runs. A preconditioner is applied
      ## locally within each domain (like bjacobi) only the local domains
      ## are extended a bit to overlap. This increases the coupling between
      ## the domain and thus improves the convergence. This does of course
      ## increase the communication cost, so iterations may be more expensive
      ## than with bjacobi.
      element preconditioner {
         attribute name { "asm" },
         subpc_options,
         comment
      }
   )

pcnone_options =
   (
      ## No preconditioner
      element preconditioner {
         attribute name { "none" },
         comment
      }
   )

# sub preconditioner to choose for bjacobi or asm
subpc_options =
   (
      ## Preconditioner to apply within the local domains
      (
         pcsor_options|
         pceisenstat_options|
         pcilu_options|
         pcicc_options|
         pclu_options|
         pcprometheus_options|
         pchypre_options|
         pcgamg_options|
         pcml_options|
         pcother_options
      )
   )
   
pcother_options =
   (
      ## Other preconditioners
      ##
      ## Any preconditioner provided by the PETSc library
      ## http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCType.html
      ## (available preconditioners may depend on the PETSc library installed on your system)
      element preconditioner {
         attribute name { xsd:string },
         comment
      }
   )
   
pcksp_options_picard =
   (
      ## A ksp preconditioner.
      ##
      ## This only makes sense for solves where a different approximated preconditioner
      ## matrix is provided.
      ##
      ## NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
      ## solve you either need to set your tolerances much stricter for it
      ## than in the outer solve (so that the preconditioner is close to an
      ## exact matrix inversion), or use fgmres in the outer solve.
      element preconditioner {
         attribute name { "ksp" },
         ## Solver options for the full solve done by this preconditioner
         element linear_solver {
            linear_solver_options_picard
         },
         comment
      }
   )

pcksp_options_snes =
   (
      ## A ksp preconditioner.
      ##
      ## This only makes sense for solves where a different approximated preconditioner
      ## matrix is provided.
      ##
      ## NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
      ## solve you either need to set your tolerances much stricter for it
      ## than in the outer solve (so that the preconditioner is close to an
      ## exact matrix inversion), or use fgmres in the outer solve.
      element preconditioner {
         attribute name { "ksp" },
         ## Solver options for the full solve done by this preconditioner
         element linear_solver {
            linear_solver_options_snes
         },
         comment
      }
   )

pclsc_options =
   (
      ## An lsc preconditioner.
      ##
      ## This only makes sense as a preconditioner for schur fieldsplit blocks.
      ##
      ## No options for the subksp are currently exposed so defaults are assumed.
      element preconditioner {
         attribute name { "lsc" },
         comment
      }
   )


pcfieldsplit_composite_types = 
  (
    (
      ## Composite type of the fieldsplit preconditioner - multiplicative - update off diagonal blocks.
      element composite_type {
        attribute name { "multiplicative" },
        comment
      }|
      ## Composite type of the fieldsplit preconditioner - symmetric multiplicative - update off diagonal symmetric blocks.
      element composite_type {
        attribute name { "symmetric_multiplicative" },
        comment
      }|
      ## Composite type of the fieldsplit preconditioner - additive - do not update off diagonal blocks.
      element composite_type {
        attribute name { "additive" },
        comment
      }|
      ## Composite type of the fieldsplit preconditioner - schur.
      ##
      ## NOTE: Only two fieldsplits may be specified.  The first is for the upper left diagonal block (A00),
      ## while the second must describe the lower right diagonal block (A11).
      element composite_type {
        attribute name { "schur" },
        (
          ## The full factorization is:
          ##
          ## (A00   A01)  = (1           0) (A00   0) (1  A00inv*A01)
          ##
          ## (A10   A11)    (A10*A00inv  1) (0     S) (0         1  )
          ##
          ## where S = A11 - A10*A00inv*A01. In practice, the full factorization is applied via block triangular solves 
          ## with the grouping L*(D*U).
          ##
          ## Upper uses D*U, lower uses L*D, and diag is the diagonal part with the sign of S flipped (because 
          ## this makes the preconditioner positive definite for many formulations, thus allowing the use of KSPMINRES).
          element factorization_type {
            attribute name { "full" },
            comment
          }|
          ## The full factorization is:
          ##
          ## (A00   A01)  = (1           0) (A00   0) (1  A00inv*A01)
          ##
          ## (A10   A11)    (A10*A00inv  1) (0     S) (0         1  )
          ##
          ## where S = A11 - A10*A00inv*A01. In practice, the full factorization is applied via block triangular solves 
          ## with the grouping L*(D*U).
          ##
          ## Upper uses D*U, lower uses L*D, and diag is the diagonal part with the sign of S flipped (because 
          ## this makes the preconditioner positive definite for many formulations, thus allowing the use of KSPMINRES).
          element factorization_type {
            attribute name { "upper" },
            comment
          }|
          ## The full factorization is:
          ##
          ## (A00   A01)  = (1           0) (A00   0) (1  A00inv*A01)
          ##
          ## (A10   A11)    (A10*A00inv  1) (0     S) (0         1  )
          ##
          ## where S = A11 - A10*A00inv*A01. In practice, the full factorization is applied via block triangular solves 
          ## with the grouping L*(D*U).
          ##
          ## Upper uses D*U, lower uses L*D, and diag is the diagonal part with the sign of S flipped (because 
          ## this makes the preconditioner positive definite for many formulations, thus allowing the use of KSPMINRES).
          element factorization_type {
            attribute name { "lower" },
            comment
          }|
          ## The full factorization is:
          ##
          ## (A00   A01)  = (1           0) (A00   0) (1  A00inv*A01)
          ##
          ## (A10   A11)    (A10*A00inv  1) (0     S) (0         1  )
          ##
          ## where S = A11 - A10*A00inv*A01. In practice, the full factorization is applied via block triangular solves 
          ## with the grouping L*(D*U).
          ##
          ## Upper uses D*U, lower uses L*D, and diag is the diagonal part with the sign of S flipped (because 
          ## this makes the preconditioner positive definite for many formulations, thus allowing the use of KSPMINRES).
          element factorization_type {
            attribute name { "diag" },
            comment
          }
        ),
        (
          ## The preconditioner for the Schur complement is generated by the block diagonal 
          ## part of the original matrix associated with the Schur complement (i.e. A11).
          ##
          ## When solving a saddle point problem, where the A11 block is identically zero, 
          ## using diag as the preconditioner only makes sense when additionally setting the pc to none. 
          ## Usually for saddle point problems one would use a preconditioner of self and pc lsc 
          ## which uses the least squares commutator compute a preconditioner for the Schur 
          ## complement.
          element schur_preconditioner {
            attribute name { "diag" },
            comment
          }|
          ## The preconditioner for the Schur complement is generated from the Schur complement matrix itself:
          ## The only preconditioner that currently works directly with the Schur complement matrix object is the PCLSC 
          ## preconditioner
          ##
          ## Usually for saddle point problems one would use a preconditioner of self and pc lsc 
          ## which uses the least squares commutator compute a preconditioner for the Schur 
          ## complement.
          element schur_preconditioner {
            attribute name { "self" },
            comment
          }|
          ## The preconditioner for the Schur complement is described by a ufl form.
          element schur_preconditioner {
            attribute name { "user" },
            ## ufl code form describing a preconditioner for the Schur block (must return a bilinear form).  
            ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
            ## defined in the preamble and bilinear form from this nonlinear_solver above.
            element form {
              attribute name { "SchurPC" },
              attribute rank { "1" },
              python3_code,
              form_ufl_symbol,
              ident_zeros
            },
            is_monitor,
            comment
          }
        ),
        comment
      }
    )
  )

pcfieldsplit_options_picard =
   (
      ## A fieldsplit preconditioner.
      element preconditioner {
         attribute name { "fieldsplit" },
         pcfieldsplit_composite_types,
         ## Describe the fieldsplits.  Names must be unique within this linear solver.
         ##
         ## Fields not included in any parent fieldsplits will be excluded from this fieldsplit 
         ## even if they are described below (a warning will be given).
         ##
         ## Fields included in any sibling fieldsplits will be excluded from this fieldsplit
         ## even if they are described below (a warning will be given).
         element fieldsplit {
           attribute name { xsd:string },
           is_fieldsplit,
           ## Solver options for the full solve done by this preconditioner
           element linear_solver {
             linear_solver_options_picard
           },
           comment
         }+,
         comment
      }
   )

pcfieldsplit_options_snes =
   (
      ## A fieldsplit preconditioner.
      element preconditioner {
         attribute name { "fieldsplit" },
         pcfieldsplit_composite_types,
         ## Describe the fieldsplits.  Names must be unique within this linear solver.
         ##
         ## Fields not included in any parent fieldsplits will be excluded from this fieldsplit 
         ## even if they are described below (a warning will be given).
         ##
         ## Fields included in any sibling fieldsplits will be excluded from this fieldsplit
         ## even if they are described below (a warning will be given).
         element fieldsplit {
           attribute name { xsd:string },
           is_fieldsplit,
           ## Solver options for the full solve done by this preconditioner
           element linear_solver {
             linear_solver_options_snes
           },
           comment
         }+,
         comment
      }
   )

# ####################################################################
#
# all the other solver options
#
# ####################################################################

iterative_solver_options_base =
   (
      ## Relative error
      ##
      ## The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
      ## Suggested value: 1.0e-7
      element relative_error {
         real
      },
      ## Absolute error bound
      ##
      ## The solver finishes if the preconditioned error becomes smaller than this value.
      ##
      ## Defaults to 1.e-50.
      element absolute_error {
         real
      }?,
      ## Divergence error bound
      ##
      ## The solver finishes if the solutions diverge by more than this value.
      ##
      ## Defaults to 10000.
      element divergence_error {
         real
      }?,
      ## Maximum number of iterations allowed in the linear solver
      ## before giving up.
      element max_iterations {
         integer
      },
      comment
   )

iterative_solver_zero_initial_guess =
  (
    ## Zero the initial guess.
    ##
    ## NOTE: some solvers always start at zero in which case this switch will have no effect.  
    ## Also the value of this switch on any parent solves may effect its behaviour.
    element zero_initial_guess {
       comment
    }
  )

iterative_solver_nonzero_initial_guess =
  (
    ## Use an initial guess from the previous solver or initial condition.
    ##
    ## NOTE: some solvers always start at zero in which case this switch will have no effect.
    ## Also the value of this switch on any parent solves may effect its behaviour.
    element nonzero_initial_guess {
      comment
    }
  )

iterative_solver_initial_guess_picard = iterative_solver_zero_initial_guess
iterative_solver_initial_guess_picard |= iterative_solver_nonzero_initial_guess

iterative_solver_initial_guess_snes = iterative_solver_nonzero_initial_guess
iterative_solver_initial_guess_snes |= iterative_solver_zero_initial_guess

iterative_solver_options_picard = iterative_solver_options_base
iterative_solver_options_picard &= iterative_monitors
iterative_solver_options_picard &= iterative_solver_initial_guess_picard

iterative_solver_options_picard_top = iterative_solver_options_base
iterative_solver_options_picard_top &= iterative_monitors_top
iterative_solver_options_picard_top &= iterative_solver_initial_guess_picard

iterative_solver_options_snes = iterative_solver_options_base
iterative_solver_options_snes &= iterative_monitors
iterative_solver_options_snes &= iterative_solver_initial_guess_snes

iterative_solver_options_snes_top = iterative_solver_options_base
iterative_solver_options_snes_top &= iterative_monitors_top
iterative_solver_options_snes_top &= iterative_solver_initial_guess_snes

iterative_monitors_base = 
  (
     ## Prints the preconditioned residual for each iteration of the solve.
     ## This is the error estimation PETSc uses during the solve.
     element preconditioned_residual {
        comment
     }?,
     ## Prints the "true" residual for each iteration of the solve,
     ## i.e. PETSc computes the L2-norm of r=A-bx. This may mean
     ## PETSc has to do extra computations.
     element true_residual {
        comment
     }?,
     ## Draws a graph over the convergence of the preconditioned residual
     ## during the solve. This option only works for systems where PETSc
     ## has been linked with the X library and with PETSc <= 3.4.
     element preconditioned_residual_graph {
        comment
     }?,
     ## Test any attached null spaces on the first iteration of the solve.
     element test_null_space {
        comment
     }?
  )

iterative_monitors_vis = 
  (
    ## Output pvd visualization of the solution and residual at each iteration.
    ## 
    ## WARNING: This will produce a lot of output so should only be used for debugging purposes!
    element visualization {
      comment
    }?,
    ## Output a diagnostic file detailing the convergence of this solver.
    element convergence_file { 
      comment
    }?
  )

iterative_monitors = 
  (
    ## Options to give extra information for each iteration of the
    ## the solve. Some of those may really slow down your computation!
    element monitors {
      iterative_monitors_base,
      comment
    }
  )

iterative_monitors_top = 
  (
    ## Options to give extra information for each iteration of the
    ## the solve. Some of those may really slow down your computation!
    element monitors {
      iterative_monitors_base,
      iterative_monitors_vis,
      comment
    }
  )

generic_solver_options =
   (
      ## Remove Null-space from residual after applying preconditioner.
      element remove_null_space {
         ## Describe the null spaces.  Names must be unique within this linear solver.
         ##
         ## Fields not included in any parent fieldsplits will be excluded from this nullspace 
         ## even if they are described below (a warning will be given).
         ##
         ## Nullspaces default to being constant over any fields described.  If no fields are specified
         ## then the entire vector is assumed to contain a constant nullspace.  To describe variable
         ## nullspaces python functions must be attached underneath the description of the field.
         element null_space {
           attribute name { xsd:string },
           is_null_space,
           comment
         }+,
         ## Parent option for null-space monitors.
         element monitors {
           ## Prints PETSc information about this null space
           element view_null_space {
             comment
           }?,
           comment
         },
         comment
      }?,
      comment
   )

snes_convergence_test = 
   (
     ## Default convergence test. See SNESConvergedReason.
     element convergence_test {
       attribute name { "default" },
       comment
     }|
     ## Skip standard convergence tests, allowing maximum iterations to be reached.
     element convergence_test {
       attribute name { "skip" },
       comment
     }
   )

