include "spud_base.rnc"
include "ufl.rnc"

nonlinear_solver_options =
  (
    (
      element nonlinear_solver {
        attribute name { xsd:string },
        (
          element type {
            snes
          }|
          element type {
            picard
          }
        )
      }|
      element nonlinear_solver {
        attribute name { "SNES" },
        element type {
          snes
        }
      }|
      element nonlinear_solver {
        attribute name { "Picard" },
        element type {
          picard
        }
      }
    )
  )

picard =
  (
    attribute name { "Picard" },
    element preamble {
      ufl 
    }?,
    element form {
      attribute name { "Bilinear" },
      attribute rank { "1" },
      form
    },
    element form {
      attribute name { "BilinearPC" },
      attribute rank { "1" },
      form
    }?,
    element form {
      attribute name { "Linear" },
      attribute rank { "0" },
      form
    },
    element form {
      attribute name { "Residual" },
      attribute rank { "0" },
      form
    },
    element relative_error {
      real
    },
    element absolute_error {
      real
    }?,
    element max_iterations {
      integer
    },
    element min_iterations {
      integer
    }?,
    element linear_solver {
      linear_solver_options
    }
  )

snes =
  (
    attribute name { "SNES" },
    element preamble {
      ufl 
    }?,
    element form {
      attribute name { "Residual" },
      attribute rank { "0" },
      form
    },
    ## Describe the Jacobian form using ufl
    element form {
      attribute name { "Jacobian" },
      attribute rank { "1" },
      form
    },
    element form {
      attribute name { "JacobianPC" },
      attribute rank { "1" },
      form
    }?,
    (
      element snes_type {
        attribute name { "ls" },
        empty
      }|
      element snes_type {
        attribute name { "tr" },
        empty
      }|
      element snes_type {
        attribute name { "python" },
        empty
      }|
      element snes_type {
        attribute name { "test" },
        empty
      }|
      element snes_type {
        attribute name { xsd:string },
        empty
      }
    ),
    element relative_error {
      real
    },
    element absolute_error {
      real
    }?,
    element solution_error {
      real
    }?,
    element max_iterations {
      integer
    },
    element max_function_evaluations {
      integer
    }?,
    ## Options to give extra information for each iteration of the
    ## the SNES solve. Some of those may really slow down your computation!
    element monitors {
       element residual {
          empty
       }?,
       element solution_graph {
          empty
       }?
    },
    element linear_solver {
      linear_solver_options
    }
  )


linear_solver_options =
   (
      ## Iterative (Krylov) method to solve the linear discretised equation
      ## Given are the most frequently used methods. The solution is done
      ## by the PETSc library. Many more methods are provided.
      ##
      (
         kspgmres_options|
         kspfgmres_options|
         kspcg_options|
         ksppreonly_options|
         ksprichardson_options|
         kspother_options
      ),
      ## Preconditioner to be used in combination with the iterative method.
      (
         pcsor_options|
         pceisenstat_options|
         pcfieldsplit_options|
         pcilu_options|
         pclu_options|
         pcprometheus_options|
         pchypre_options|
         pcbjacobi_options|
         pcasm_options|
         pcksp_options|
         pcother_options
      ),
      generic_solver_options
   )

# ####################################################################
#
# options for the different iterative ksp methods
#
# ####################################################################

kspgmres_options =
   (
      ## GMRES
      ##
      ## Your safest bet for non-symmetric systems.
      element iterative_method {
         attribute name { "gmres" },
         ## Restart value for gmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options
      }
   )
   
kspfgmres_options =
   (
      ## FGMRES
      element iterative_method {
         attribute name { "fgmres" },
         ## Restart value for fgmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options
      }
   )
   
kspcg_options =
   (
      ## Conjugate gradient method
      ##
      ## Only works for symmetric systems.
      element iterative_method {
         attribute name { "cg" },
         iterative_solver_options
      }
   )

ksppreonly_options =
   (
      ## Direct method
      ##
      ## This is for non-iterative methods
      ## Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.
      element iterative_method {
         attribute name { "preonly" }
      }
   )
   
ksprichardson_options =
   (
      ## Richardson iteration
      ##
      ## Only apply preconditioner each iteration, no krylov acceleration
      element iterative_method {
         attribute name { "richardson" },
         iterative_solver_options
      }
   )
   
kspother_options =
   (
      ## Other methods
      ##
      ## Any method provided by the PETSc library
      ## http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
      ## (available methods may depend on the PETSc library installed on your system)
      element iterative_method {
         attribute name { xsd:string },
         iterative_solver_options
      }
   )
   
# ####################################################################
#
# options for the different preconditioners
#
# ####################################################################

pcsor_options =
   (
      ## Succesive Over-Relaxation
      ##
      ## This includes SSOR (symmetric sor)
      element preconditioner {
         attribute name { "sor" }
      }
   )
   
pceisenstat_options =
   (
      ## The Eisenstat method
      ##
      ## This preconditioner is equivalent to SOR but only uses
      ## half the number of flops,
      ## i.e. same convergence rate but twice as fast per
      ## iteration. Because it computes
      ## a different preconditioned residual the convergence in
      ## practice may be quite different though.
      element preconditioner {
         attribute name { "eisenstat" }
      }
   )
   
pcilu_options = 
   (
      ## Incomplete LU decomposition
      element preconditioner {
         attribute name { "ilu" }
      }
   )
   
pcicc_options =
   (
      ## Incomplete Cholesky decomposition (only works for symmetric matrices)
      element preconditioner {
         attribute name { "icc" }
      }
   )
   
pclu_options =
   (
      ## LU direct solver
      ##
      ## This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.
      element preconditioner {
         attribute name { "lu" },
         (
           element factorization_package {
             attribute name { "petsc" },
             empty
           }|
           element factorization_package {
             attribute name { "umfpack" },
             empty
           }|
           element factorization_package {
             attribute name { "mumps" },
             empty
           }|
           element factorization_package {
             attribute name { xsd:string },
             empty
           }
         )
     }
   )

pcprometheus_options =
   (
      ## Prometheus multigrid method
      element preconditioner {
         attribute name { "prometheus" }
      }
   )

pchypre_options =
   (
      ## Hypre preconditioners (includes boomeramg)
      element preconditioner {
         attribute name { "hypre" },
         (
            ## BoomerAMG multigrid method
            element hypre_type {
               attribute name { "boomeramg" }
            }|
            ## Other Hypre preconditioners
            element hypre_type {
               attribute name { string }
            }
         )
      }
   )

pcbjacobi_options =
   (
      ## Block Jacobi
      ##
      ## This option is for parallel runs. A preconditioner is applied
      ## locally within each domain. This means within the domain you can
      ## choose whatever preconditioner you would choose in serial. Because
      ## there is no coupling between the domains in the preconditioning
      ## the performance may be less than in serial and degrade with 
      ## increasing number of processors/decreasing local domain size.
      element preconditioner {
         attribute name { "bjacobi" },
         subpc_options
      }
   )

pcasm_options =
   (
      ## Additive Schwartz Method
      ##
      ## This option is for parallel runs. A preconditioner is applied
      ## locally within each domain (like bjacobi) only the local domains
      ## are extended a bit to overlap. This increases the coupling between
      ## the domain and thus improves the convergence. This does of course
      ## increase the communication cost, so iterations may be more expensive
      ## than with bjacobi.
      element preconditioner {
         attribute name { "asm" },
         subpc_options
      }
   )

# sub preconditioner to choose for bjacobi or asm
subpc_options =
   (
      ## Preconditioner to apply within the local domains
      (
         pcsor_options|
         pceisenstat_options|
         pcilu_options|
         pcicc_options|
         pclu_options|
         pcmg_options|
         pcprometheus_options|
         pchypre_options|
         pcother_options
      )
   )
   
pcother_options =
   (
      ## Other preconditioners
      ##
      ## Any preconditioner provided by the PETSc library
      ## http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
      ## (available preconditiors may depend on the PETSc library installed on your system)
      element preconditioner {
         attribute name { string }
      }
   )
   
pcksp_options =
   (
      ## This only makes sense for solves where a different approximated preconditioner
      ## matrix is provided.
      ##
      ## NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
      ## solve you either need to set your tolerances much stricter for it
      ## than in the outer solve (so that the preconditioner is close to an
      ## exact matrix inversion), or use fgmres in the outer solve.
      element preconditioner {
         attribute name { "ksp" },
         ## Solver options for the full solve done by this preconditioner
         element linear_solver {
            linear_solver_options
         }
      }
   )

pcfieldsplit_options =
   (
      element preconditioner {
         attribute name { "fieldsplit" },
         (
           element composite_type {
             attribute name { "additive" },
             empty
           }|
           element composite_type {
             attribute name { "multiplicative" },
             empty
           }|
           element composite_type {
             attribute name { "symmetric_multiplicative" },
             empty
           }|
           element composite_type {
             attribute name { "special" },
             empty
           }|
           element composite_type {
             attribute name { "schur" },
             empty
           }
         ),
         element fieldsplit {
           attribute name { xsd:string },
           element field {
             attribute name { xsd:string },
             ## If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).
             ##
             ## Defaults to all components if not selected.
             element components {
               integer_vector
             }?,
             ## A list of the region ids (physical ids in gmsh) 
             element region_ids {
               integer_vector
             }?
           }+,
           ## Solver options for the full solve done by this preconditioner
           element linear_solver {
             linear_solver_options
           }
         }+
      }
   )

# ####################################################################
#
# all the other solver options
#
# ####################################################################

iterative_solver_options =
   (
      ## Relative error
      ##
      ## The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
      ## Suggested value: 1.0e-7
      element relative_error {
         real
      },
      ## Absolute error bound
      ##
      ## The solver finishes if the preconditioned error becomes smaller than this value.
      element absolute_error {
         real
      }?,
      ## Divergence error bound
      ##
      ## The solver finishes if the solutions diverge by more than this value.
      element divergence_error {
         real
      }?,
      ## Maximum number of iterations allowed in the linear solver
      ## before giving up.
      element max_iterations {
         integer
      },
      ## Options to give extra information for each iteration of the
      ## the solve. Some of those may really slow down your computation!
      element monitors {
         ## Prints the preconditioned residual for each iteration of the solve.
         ## This is the error estimation PETSc uses during the solve.
         element preconditioned_residual {
            empty
         }?,
         ## Prints the "true" residual for each iteration of the solve,
         ## i.e. PETSc computes the L2-norm of r=A-bx. This may mean
         ## PETSc has to do extra computations.
         element true_residual {
            empty
         }?,
         ## Draws a graph over the convergence of the preconditioned residual
         ## during the solve. This option only works for systems where PETSc
         ## has been linked with the X library.
         element preconditioned_residual_graph {
            empty
         }?
#         ## Prints the error by computing the difference with the provided
#         ## exact solution each time step.
#         element true_error {
#            ## Give the field name of the field that contains the exact
#            ## solution to be compared with each iteration
#            attribute coefficient {
#               attribute name { xsd:string },
#               empty
#            }
#         }?,
#         ## Writes out the approximate solution to a vtu each iteration.
#         ## <b>This may create a large number of vtus!</b>
#         element iteration_vtus {
#            empty
#         }?
     }
   )

generic_solver_options =
   (
#      ## Switch on to not use an initial guess from a previous solve but
#      ## start with a zero vector. Note that some of the solves always
#      ## start at zero in which case this switch will have no effect (see the log output).
#      element start_from_zero {
#         empty
#      }?,
      ## Remove Null-space from residual after applying preconditioner.
      element remove_null_space {
         element null_space {
           attribute name { xsd:string },
           element field {
             attribute name { xsd:string },
             ## If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).
             ##
             ## Defaults to all components if not selected.
             element components {
               integer_vector
             }?,
             ## A list of the region ids (physical ids in gmsh) 
             element region_ids {
               integer_vector
             }?
           }+
         }+
      }?
   )

