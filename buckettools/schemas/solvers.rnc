include "spud_base.rnc"
include "ufl.rnc"

nonlinear_solver_options =
  (
    ## Options describing a nonlinear solver.  This consists of a set of bilinear and linear forms acting on the function 
    ## and functionspace in this system and using coefficients defined anywhere in this options file.  Additionally a nonlinear
    ## solver describes the method of convering the nonlinear solve, either using a Newton or Picard iteration loop and a
    ## description of the linear solver used within this loop.
    element nonlinear_solver {
      attribute name { xsd:string },
      (
        ## The type of nonlinear solver. 
        ## PETSc SNES - a Newton iteration with line search.
        element type {
          snes
        }|
        ## The type of nonlinear solver. 
        ## A Picard iteration.
        element type {
          picard
        }
      )
    }
  )

picard =
  (
    attribute name { "Picard" },
    ## ufl code preamble to the forms defined below.  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this preamble.
    element preamble {
      python_code 
    }?,
    ## ufl code form describing a bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble above.
    element form {
      attribute name { "Bilinear" },
      attribute rank { "1" },
      python_code,
      form_ufl_symbol
    },
    ## ufl code form describing a preconditioner bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and bilinear form above.
    ##
    ## If undefined the bilinear form above will be used to precondition itself.
    element form {
      attribute name { "BilinearPC" },
      attribute rank { "1" },
      python_code,
      form_ufl_symbol
    }?,
    ## ufl code form describing a linear form (must return a linear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and bilinear forms above.
    element form {
      attribute name { "Linear" },
      attribute rank { "0" },
      python_code,
      form_ufl_symbol
    },
    ## ufl code form describing a linear residual form (must return a linear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble, bilinear and linear forms above.
    element form {
      attribute name { "Residual" },
      attribute rank { "0" },
      ## ufl code describing a form.
      python_code,
      form_ufl_symbol
    },
    ## The relative error allowed to remain in the vector l2 norm of the nonlinear solver residual (defined above) upon termination
    ## of the iteration loop.
    element relative_error {
      real
    },
    ## The absolute error allowed to remain in the vector l2 norm of the nonlinear solver residual (defined above) upon termination
    ## of the iteration loop.
    ##
    ## Defaults to 1.e-50.
    element absolute_error {
      real
    }?,
    ## The maximum number of iterations to take in this nonlinear solver loop.
    element max_iterations {
      integer
    },
    ## The minimum number of iterations to take in this nonlinear solver loop.
    element min_iterations {
      integer
    }?,
    ## Options describing a linear solver.
    element linear_solver {
      linear_solver_options
    }
  )

snes =
  (
    attribute name { "SNES" },
    ## ufl code preamble to the forms defined below.  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this preamble.
    element preamble {
      python_code
    }?,
    ## ufl code form describing a linear residual form (must return a linear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble above.
    element form {
      attribute name { "Residual" },
      attribute rank { "0" },
      python_code,
      form_ufl_symbol
    },
    ## ufl code form describing a jacobian bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and residual linear form above.
    element form {
      attribute name { "Jacobian" },
      attribute rank { "1" },
      python_code,
      form_ufl_symbol
    },
    ## ufl code form describing a preconditioner jacobian bilinear form (must return a bilinear form).  
    ## Any system, field or coefficient ufl symbols defined in this options file may be used in this form as well as any symbols 
    ## defined in the preamble and bilinear form above.
    ##
    ## If undefined the jacobian bilinear form above will be used to precondition itself.
    element form {
      attribute name { "JacobianPC" },
      attribute rank { "1" },
      python_code,
      form_ufl_symbol
    }?,
    (
      ## The SNES type.  Line search.
      element snes_type {
        attribute name { "ls" },
        empty
      }|
      ## The SNES type.
      element snes_type {
        attribute name { "tr" },
        empty
      }|
      ## The SNES type.
      element snes_type {
        attribute name { "python" },
        empty
      }|
      ## The SNES type.
      element snes_type {
        attribute name { "test" },
        empty
      }|
      ## The SNES type.  Any valid PETSc SNES type may be entered.
      element snes_type {
        attribute name { xsd:string },
        empty
      }
    ),
    ## The relative error allowed to remain in the l2 norm of the nonlinear solver residual upon termination
    ## of the iteration loop.
    element relative_error {
      real
    },
    ## The absolute error allowed to remain in the vector l2 norm of the nonlinear solver residual upon termination
    ## of the iteration loop.
    ##
    ## Defaults to 1.e-50.
    element absolute_error {
      real
    }?,
    ## Defaults to 1.e-8.
    element solution_error {
      real
    }?,
    ## The maximum number of iterations to take in this nonlinear solver loop.
    element max_iterations {
      integer
    },
    ## The maximum number of solver evaluations allowed in this nonlinear solver loop.
    ##
    ## Defaults to 10000.
    element max_function_evaluations {
      integer
    }?,
    ## Options to give extra information for each iteration of the
    ## the SNES solve. Some of those may really slow down your computation!
    element monitors {
       ## Output the residual at every function evaluation.
       element residual {
          empty
       }?,
       ## Plot a graph of the solution with each iteration.
       element solution_graph {
          empty
       }?
    },
    ## Options describing a linear solver.
    element linear_solver {
      linear_solver_options
    }
  )


linear_solver_options =
   (
      ## Iterative (Krylov) method to solve the linear discretised equation
      ## Given are the most frequently used methods. The solution is done
      ## by the PETSc library. Many more methods are provided.
      (
         kspgmres_options|
         kspfgmres_options|
         kspcg_options|
         ksppreonly_options|
         ksprichardson_options|
         kspother_options
      ),
      ## Preconditioner to be used in combination with the iterative method.
      (
         pcsor_options|
         pceisenstat_options|
         pcfieldsplit_options|
         pcilu_options|
         pclu_options|
         pcprometheus_options|
         pchypre_options|
         pcbjacobi_options|
         pcasm_options|
         pcksp_options|
         pcother_options
      ),
      generic_solver_options
   )

# ####################################################################
#
# options for the different iterative ksp methods
#
# ####################################################################

kspgmres_options =
   (
      ## GMRES
      ##
      ## Your safest bet for non-symmetric systems.
      element iterative_method {
         attribute name { "gmres" },
         ## Restart value for gmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options
      }
   )
   
kspfgmres_options =
   (
      ## FGMRES
      element iterative_method {
         attribute name { "fgmres" },
         ## Restart value for fgmres iteration
         ## Higher values give better convergence but require more memory.
         ## Suggested value: 30
         element restart {
            integer
         },
         iterative_solver_options
      }
   )
   
kspcg_options =
   (
      ## Conjugate gradient method
      ##
      ## Only works for symmetric systems.
      element iterative_method {
         attribute name { "cg" },
         iterative_solver_options
      }
   )

ksppreonly_options =
   (
      ## Direct method
      ##
      ## This is for non-iterative methods
      ## Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.
      element iterative_method {
         attribute name { "preonly" }
      }
   )
   
ksprichardson_options =
   (
      ## Richardson iteration
      ##
      ## Only apply preconditioner each iteration, no krylov acceleration
      element iterative_method {
         attribute name { "richardson" },
         iterative_solver_options
      }
   )
   
kspother_options =
   (
      ## Other methods
      ##
      ## Any method provided by the PETSc library
      ## http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
      ## (available methods may depend on the PETSc library installed on your system)
      element iterative_method {
         attribute name { xsd:string },
         iterative_solver_options
      }
   )
   
# ####################################################################
#
# options for the different preconditioners
#
# ####################################################################

pcsor_options =
   (
      ## Succesive Over-Relaxation
      ##
      ## This includes SSOR (symmetric sor)
      element preconditioner {
         attribute name { "sor" }
      }
   )
   
pceisenstat_options =
   (
      ## The Eisenstat method
      ##
      ## This preconditioner is equivalent to SOR but only uses
      ## half the number of flops,
      ## i.e. same convergence rate but twice as fast per
      ## iteration. Because it computes
      ## a different preconditioned residual the convergence in
      ## practice may be quite different though.
      element preconditioner {
         attribute name { "eisenstat" }
      }
   )
   
pcilu_options = 
   (
      ## Incomplete LU decomposition
      element preconditioner {
         attribute name { "ilu" }
      }
   )
   
pcicc_options =
   (
      ## Incomplete Cholesky decomposition (only works for symmetric matrices)
      element preconditioner {
         attribute name { "icc" }
      }
   )
   
pclu_options =
   (
      ## LU direct solver
      ##
      ## This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.
      element preconditioner {
         attribute name { "lu" },
         (
           ## Package to use for the factorization - petsc.
           element factorization_package {
             attribute name { "petsc" },
             empty
           }|
           ## Package to use for the factorization - umfpack.
           ##
           ## Useful for systems with a near zero pivot.
           element factorization_package {
             attribute name { "umfpack" },
             empty
           }|
           ## Package to use for the factorization - mumps.
           ##
           ## Useful for parallel direct solves (if installed on system).
           element factorization_package {
             attribute name { "mumps" },
             empty
           }|
           ## Package to use for the factorization - any valid package.
           element factorization_package {
             attribute name { xsd:string },
             empty
           }
         )
     }
   )

pcprometheus_options =
   (
      ## Prometheus multigrid method
      element preconditioner {
         attribute name { "prometheus" }
      }
   )

pchypre_options =
   (
      ## Hypre preconditioners (includes boomeramg)
      element preconditioner {
         attribute name { "hypre" },
         (
            ## BoomerAMG multigrid method
            element hypre_type {
               attribute name { "boomeramg" }
            }|
            ## Other Hypre preconditioners
            element hypre_type {
               attribute name { string }
            }
         )
      }
   )

pcbjacobi_options =
   (
      ## Block Jacobi
      ##
      ## This option is for parallel runs. A preconditioner is applied
      ## locally within each domain. This means within the domain you can
      ## choose whatever preconditioner you would choose in serial. Because
      ## there is no coupling between the domains in the preconditioning
      ## the performance may be less than in serial and degrade with 
      ## increasing number of processors/decreasing local domain size.
      element preconditioner {
         attribute name { "bjacobi" },
         subpc_options
      }
   )

pcasm_options =
   (
      ## Additive Schwartz Method
      ##
      ## This option is for parallel runs. A preconditioner is applied
      ## locally within each domain (like bjacobi) only the local domains
      ## are extended a bit to overlap. This increases the coupling between
      ## the domain and thus improves the convergence. This does of course
      ## increase the communication cost, so iterations may be more expensive
      ## than with bjacobi.
      element preconditioner {
         attribute name { "asm" },
         subpc_options
      }
   )

# sub preconditioner to choose for bjacobi or asm
subpc_options =
   (
      ## Preconditioner to apply within the local domains
      (
         pcsor_options|
         pceisenstat_options|
         pcilu_options|
         pcicc_options|
         pclu_options|
         pcmg_options|
         pcprometheus_options|
         pchypre_options|
         pcother_options
      )
   )
   
pcother_options =
   (
      ## Other preconditioners
      ##
      ## Any preconditioner provided by the PETSc library
      ## http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
      ## (available preconditiors may depend on the PETSc library installed on your system)
      element preconditioner {
         attribute name { string }
      }
   )
   
pcksp_options =
   (
      ## A ksp preconditioner.
      ##
      ## This only makes sense for solves where a different approximated preconditioner
      ## matrix is provided.
      ##
      ## NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
      ## solve you either need to set your tolerances much stricter for it
      ## than in the outer solve (so that the preconditioner is close to an
      ## exact matrix inversion), or use fgmres in the outer solve.
      element preconditioner {
         attribute name { "ksp" },
         ## Solver options for the full solve done by this preconditioner
         element linear_solver {
            linear_solver_options
         }
      }
   )

pcfieldsplit_options =
   (
      ## A fieldsplit preconditioner.
      element preconditioner {
         attribute name { "fieldsplit" },
         (
           ## Composite type of the fieldsplit preconditioner - additive - do not update off diagonal blocks.
           element composite_type {
             attribute name { "additive" },
             empty
           }|
           ## Composite type of the fieldsplit preconditioner - multiplicative - update off diagonal blocks.
           element composite_type {
             attribute name { "multiplicative" },
             empty
           }|
           ## Composite type of the fieldsplit preconditioner - symmetric_multiplicative - update off diagonal blocks.
           element composite_type {
             attribute name { "symmetric_multiplicative" },
             empty
           }|
           ## Composite type of the fieldsplit preconditioner - special.
           element composite_type {
             attribute name { "special" },
             empty
           }|
           ## Composite type of the fieldsplit preconditioner - schur.
           element composite_type {
             attribute name { "schur" },
             empty
           }
         ),
         ## Describe the fieldsplits.  Names must be unique within this linear solver.
         ##
         ## Each fieldsplit must fully describe the split from the base system function (i.e. field names, region ids and components are not
         ## inherited down the tree of splits).
         element fieldsplit {
           attribute name { xsd:string },
           ## Field to include in this split.
           element field {
             attribute name { xsd:string },
             ## If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).
             ##
             ## Defaults to all components if not selected.
             element components {
               integer_vector
             }?,
             ## A list of the region ids (physical ids in gmsh) 
             element region_ids {
               integer_vector
             }?
           }+,
           ## Solver options for the full solve done by this preconditioner
           element linear_solver {
             linear_solver_options
           }
         }+
      }
   )

# ####################################################################
#
# all the other solver options
#
# ####################################################################

iterative_solver_options =
   (
      ## Relative error
      ##
      ## The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
      ## Suggested value: 1.0e-7
      element relative_error {
         real
      },
      ## Absolute error bound
      ##
      ## The solver finishes if the preconditioned error becomes smaller than this value.
      ##
      ## Defaults to 1.e-50.
      element absolute_error {
         real
      }?,
      ## Divergence error bound
      ##
      ## The solver finishes if the solutions diverge by more than this value.
      ##
      ## Defaults to 10000.
      element divergence_error {
         real
      }?,
      ## Maximum number of iterations allowed in the linear solver
      ## before giving up.
      element max_iterations {
         integer
      },
      ## Options to give extra information for each iteration of the
      ## the solve. Some of those may really slow down your computation!
      element monitors {
         ## Prints the preconditioned residual for each iteration of the solve.
         ## This is the error estimation PETSc uses during the solve.
         element preconditioned_residual {
            empty
         }?,
         ## Prints the "true" residual for each iteration of the solve,
         ## i.e. PETSc computes the L2-norm of r=A-bx. This may mean
         ## PETSc has to do extra computations.
         element true_residual {
            empty
         }?,
         ## Draws a graph over the convergence of the preconditioned residual
         ## during the solve. This option only works for systems where PETSc
         ## has been linked with the X library.
         element preconditioned_residual_graph {
            empty
         }?
#         ## Prints the error by computing the difference with the provided
#         ## exact solution each time step.
#         element true_error {
#            ## Give the field name of the field that contains the exact
#            ## solution to be compared with each iteration
#            attribute coefficient {
#               attribute name { xsd:string },
#               empty
#            }
#         }?,
#         ## Writes out the approximate solution to a vtu each iteration.
#         ## <b>This may create a large number of vtus!</b>
#         element iteration_vtus {
#            empty
#         }?
     }
   )

generic_solver_options =
   (
#      ## Switch on to not use an initial guess from a previous solve but
#      ## start with a zero vector. Note that some of the solves always
#      ## start at zero in which case this switch will have no effect (see the log output).
#      element start_from_zero {
#         empty
#      }?,
      ## Remove Null-space from residual after applying preconditioner.
      element remove_null_space {
         ## Describe the null spaces.  Names must be unique within this linear solver.
         ##
         ## Each null space must fully describe the space from the base system function (i.e. field names, region ids and components are not
         ## inherited down the tree).
         element null_space {
           attribute name { xsd:string },
           ## Field to include in this null space.
           element field {
             attribute name { xsd:string },
             ## If this field is a vector or a tensor components may be listed (indexed from 0 by row first if tensorial).
             ##
             ## Defaults to all components if not selected.
             element components {
               integer_vector
             }?,
             ## A list of the region ids (physical ids in gmsh).
             ##
             ## Defaults to the whole mesh if left unspecified.
             element region_ids {
               integer_vector
             }?
           }+
         }+
      }?
   )

