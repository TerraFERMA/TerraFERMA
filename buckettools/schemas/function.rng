<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="element.rng"/>
  <include href="ufl.rng"/>
  <define name="field_options">
    <element name="field">
      <a:documentation>Options describing a field (a prognostic function) in this system</a:documentation>
      <ref name="field_header_options"/>
      <element name="type">
        <a:documentation>The type of field (no option available).

Fields may only be prognostic functions.</a:documentation>
        <attribute name="name">
          <value>Function</value>
        </attribute>
        <choice>
          <element name="rank">
            <a:documentation>The rank of the field (scalar, rank 0).</a:documentation>
            <attribute name="name">
              <value>Scalar</value>
            </attribute>
            <ref name="scalar_field_function_options"/>
          </element>
          <element name="rank">
            <a:documentation>The rank of the field (vector, rank 1).</a:documentation>
            <attribute name="name">
              <value>Vector</value>
            </attribute>
            <ref name="vector_field_function_options"/>
          </element>
          <element name="rank">
            <a:documentation>The rank of the field (tensor, rank 2).</a:documentation>
            <attribute name="name">
              <value>Tensor</value>
            </attribute>
            <ref name="tensor_field_function_options"/>
          </element>
        </choice>
      </element>
      <ref name="generic_function_diagnostics_options"/>
    </element>
  </define>
  <define name="coefficient_options">
    <element name="coefficient">
      <a:documentation>Options describing a coefficient in this system</a:documentation>
      <ref name="coeff_header_options"/>
      <choice>
        <element name="type">
          <a:documentation>The type of coefficient.

Functions require a functionspace, which will be defined on the same mesh as the system in which this coefficient falls.</a:documentation>
          <attribute name="name">
            <value>Function</value>
          </attribute>
          <choice>
            <element name="rank">
              <a:documentation>The rank of the coefficient (scalar, rank 0).</a:documentation>
              <attribute name="name">
                <value>Scalar</value>
              </attribute>
              <ref name="scalar_coefficient_function_expression_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (vector, rank 1).</a:documentation>
              <attribute name="name">
                <value>Vector</value>
              </attribute>
              <ref name="vector_coefficient_function_expression_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (tensor, rank 2).</a:documentation>
              <attribute name="name">
                <value>Tensor</value>
              </attribute>
              <ref name="tensor_coefficient_function_expression_options"/>
            </element>
          </choice>
        </element>
        <element name="type">
          <a:documentation>The type of coefficient.

Expressions are not defined on functionspaces but require an element to be described in ufl.</a:documentation>
          <attribute name="name">
            <value>Expression</value>
          </attribute>
          <choice>
            <element name="rank">
              <a:documentation>The rank of the coefficient (scalar, rank 0).</a:documentation>
              <attribute name="name">
                <value>Scalar</value>
              </attribute>
              <ref name="scalar_coefficient_function_expression_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (vector, rank 1).</a:documentation>
              <attribute name="name">
                <value>Vector</value>
              </attribute>
              <ref name="vector_coefficient_function_expression_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (tensor, rank 2).</a:documentation>
              <attribute name="name">
                <value>Tensor</value>
              </attribute>
              <ref name="tensor_coefficient_function_expression_options"/>
            </element>
          </choice>
        </element>
        <element name="type">
          <a:documentation>The type of coefficient.

Constants are spatially constant expressions.</a:documentation>
          <attribute name="name">
            <value>Constant</value>
          </attribute>
          <choice>
            <element name="rank">
              <a:documentation>The rank of the coefficient (scalar, rank 0).</a:documentation>
              <attribute name="name">
                <value>Scalar</value>
              </attribute>
              <ref name="scalar_coefficient_constant_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (vector, rank 1).</a:documentation>
              <attribute name="name">
                <value>Vector</value>
              </attribute>
              <ref name="vector_coefficient_constant_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (tensor, rank 2).</a:documentation>
              <attribute name="name">
                <value>Tensor</value>
              </attribute>
              <ref name="tensor_coefficient_constant_options"/>
            </element>
          </choice>
        </element>
      </choice>
      <ref name="generic_function_diagnostics_options"/>
    </element>
  </define>
  <define name="scalar_field_function_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="element_options_scalar"/>
    <oneOrMore>
      <ref name="initial_condition_scalar"/>
    </oneOrMore>
    <zeroOrMore>
      <ref name="boundary_condition_scalar"/>
    </zeroOrMore>
  </define>
  <define name="vector_field_function_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="element_options_vector"/>
    <oneOrMore>
      <ref name="initial_condition_vector"/>
    </oneOrMore>
    <zeroOrMore>
      <ref name="boundary_condition_vector"/>
    </zeroOrMore>
  </define>
  <define name="tensor_field_function_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="element_options_tensor"/>
    <oneOrMore>
      <ref name="initial_condition_tensor"/>
    </oneOrMore>
    <zeroOrMore>
      <ref name="boundary_condition_tensor"/>
    </zeroOrMore>
  </define>
  <define name="scalar_coefficient_function_expression_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="element_options_scalar"/>
    <oneOrMore>
      <ref name="prescribed_expression_scalar"/>
    </oneOrMore>
  </define>
  <define name="vector_coefficient_function_expression_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="element_options_vector"/>
    <oneOrMore>
      <ref name="prescribed_expression_vector"/>
    </oneOrMore>
  </define>
  <define name="tensor_coefficient_function_expression_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="element_options_tensor"/>
    <oneOrMore>
      <ref name="prescribed_expression_tensor"/>
    </oneOrMore>
  </define>
  <define name="scalar_coefficient_constant_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="prescribed_constant_scalar"/>
  </define>
  <define name="vector_coefficient_constant_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="prescribed_constant_vector"/>
  </define>
  <define name="tensor_coefficient_constant_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="prescribed_constant_tensor"/>
  </define>
  <define name="field_header_options">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <ref name="field_ufl_symbol"/>
  </define>
  <define name="coeff_header_options">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <ref name="coeff_ufl_symbol"/>
  </define>
  <define name="generic_function_diagnostics_options">
    <element name="diagnostics">
      <a:documentation>Output options</a:documentation>
      <optional>
        <element name="include_in_diagnostics">
          <a:documentation>Include this field or coefficient in the diagnostic output file.
The minimum and maximum of functions is included.</a:documentation>
          <zeroOrMore>
            <ref name="functional_options"/>
          </zeroOrMore>
        </element>
      </optional>
      <optional>
        <element name="include_in_steadystate">
          <a:documentation>Include this field or coefficient in the steady state check and output file.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_in_detectors">
          <a:documentation>Include this field or coefficient in the detectors output file.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="functional_options">
    <element name="functional">
      <a:documentation>ufl code and symbol describing a functional.  This must return a single number and have a unique name beneath this field or coefficient.</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="python_code"/>
      <ref name="functional_ufl_symbol"/>
    </element>
  </define>
  <define name="initial_condition_scalar">
    <choice>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over the whole domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="prescribed_scalar"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over a subset of the whole domain</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this  condition applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_scalar"/>
      </element>
    </choice>
  </define>
  <define name="initial_condition_vector">
    <choice>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over the whole domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="prescribed_vector"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over a subset of the whole domain</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this condition applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_vector"/>
      </element>
    </choice>
  </define>
  <define name="initial_condition_tensor">
    <choice>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over the whole domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="prescribed_tensor"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over a subset of the whole domain</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this condition applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_tensor"/>
      </element>
    </choice>
  </define>
  <define name="boundary_condition_scalar">
    <element name="boundary_condition">
      <a:documentation>Options for the description of a boundary condition</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh) that this condition applies to  </a:documentation>
        <ref name="integer_vector"/>
      </element>
      <element name="sub_components">
        <a:documentation>There are no sub components to a scalar so this is just a dummy tree level for consistency with a vector function</a:documentation>
        <attribute name="name">
          <value>All</value>
        </attribute>
        <element name="type">
          <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
          <attribute name="name">
            <value>Dirichlet</value>
          </attribute>
          <ref name="prescribed_scalar"/>
        </element>
      </element>
    </element>
  </define>
  <define name="boundary_condition_vector">
    <element name="boundary_condition">
      <a:documentation>Options for the description of a boundary condition</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh) that this condition applies to  </a:documentation>
        <ref name="integer_vector"/>
      </element>
      <oneOrMore>
        <choice>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to all the vector components on this boundary_id</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <ref name="prescribed_vector"/>
            </element>
          </element>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to a subset of the vector components on this boundary_id</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector components to which this boundary condition applies (indexes from 0)</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <ref name="prescribed_scalar"/>
            </element>
          </element>
        </choice>
      </oneOrMore>
    </element>
  </define>
  <define name="boundary_condition_tensor">
    <element name="boundary_condition">
      <a:documentation>Options for the description of a boundary condition</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh) that this condition applies to  </a:documentation>
        <ref name="integer_vector"/>
      </element>
      <oneOrMore>
        <choice>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to all the tensor components on this boundary_id</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <ref name="prescribed_tensor"/>
            </element>
          </element>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to a subset of the tensor components on this boundary_id</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="components">
              <a:documentation>A list of the tensor components to which this boundary condition applies (indexes from 0 by row first)</a:documentation>
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <ref name="integer_vector"/>
            </element>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <ref name="prescribed_scalar"/>
            </element>
          </element>
        </choice>
      </oneOrMore>
    </element>
  </define>
  <define name="prescribed_constant_scalar">
    <element name="value">
      <a:documentation>Options for the description of an expression over the domain</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="prescribed_scalar_constant"/>
    </element>
  </define>
  <define name="prescribed_constant_vector">
    <element name="value">
      <a:documentation>Options for the description of an expression over the domain</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="prescribed_vector_constant"/>
    </element>
  </define>
  <define name="prescribed_constant_tensor">
    <element name="value">
      <a:documentation>Options for the description of an expression over the domain</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="prescribed_tensor_constant"/>
    </element>
  </define>
  <define name="prescribed_expression_scalar">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="prescribed_scalar"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_scalar"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_expression_vector">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="prescribed_vector"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_vector"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_expression_tensor">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="prescribed_tensor"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_tensor"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_scalar_constant">
    <element name="constant">
      <a:documentation>A constant scalar</a:documentation>
      <ref name="real"/>
    </element>
  </define>
  <define name="prescribed_vector_constant">
    <choice>
      <element name="constant">
        <a:documentation>A constant vector of length /geometry/dimension</a:documentation>
        <attribute name="name">
          <value>dim</value>
        </attribute>
        <ref name="real_dim_vector"/>
      </element>
      <element name="constant">
        <a:documentation>A constant vector of arbitrary length (must be the same as the size of the vector element).</a:documentation>
        <attribute name="name">
          <value>arbitrary</value>
        </attribute>
        <ref name="real_vector"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_tensor_constant">
    <choice>
      <element name="constant">
        <a:documentation>A constant tensor of shape /geometry/dimension x /geometry/dimension</a:documentation>
        <attribute name="name">
          <value>dim</value>
        </attribute>
        <ref name="real_dim_tensor"/>
      </element>
      <element name="constant">
        <a:documentation>A constant tensor of arbitrary shape (must be the same as the size of the tensor element).  
Values should be entered by row first.</a:documentation>
        <attribute name="name">
          <value>arbitrary</value>
        </attribute>
        <ref name="real_tensor"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_scalar_python">
    <element name="python">
      <a:documentation>A scalar described by a python function.

Functions should be of the form:

 def val(x):
    # Function code
    return ... # Return value

The return value should be scalar.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="prescribed_vector_python">
    <element name="python">
      <a:documentation>A vector described by a python function.

Functions should be of the form:

 def val(x):
    # Function code
    return [..., ...] # Return value

The return value must have the same size as the vector element.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="prescribed_tensor_python">
    <element name="python">
      <a:documentation>A tensor described by a python function.

Functions should be of the form:

 def val(x):
    # Function code
    return [[..., ...],[..., ...],...] # Return value

The return value must have the same shape as the tensor element.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="prescribed_scalar">
    <ref name="prescribed_scalar_python"/>
  </define>
  <define name="prescribed_scalar" combine="choice">
    <ref name="prescribed_scalar_constant"/>
  </define>
  <define name="prescribed_vector">
    <ref name="prescribed_vector_python"/>
  </define>
  <define name="prescribed_vector" combine="choice">
    <ref name="prescribed_vector_constant"/>
  </define>
  <define name="prescribed_tensor">
    <ref name="prescribed_tensor_python"/>
  </define>
  <define name="prescribed_tensor" combine="choice">
    <ref name="prescribed_tensor_constant"/>
  </define>
</grammar>
