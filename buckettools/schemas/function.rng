<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!--
    Copyright (C) 2013 Columbia University in the City of New York and others.
    
    Please see the AUTHORS file in the main source directory for a full list
    of contributors.
    
    This file is part of TerraFERMA.
    
    TerraFERMA is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    TerraFERMA is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with TerraFERMA. If not, see <http://www.gnu.org/licenses/>.
  -->
  <include href="spud_base.rng"/>
  <include href="element.rng"/>
  <include href="ufl.rng"/>
  <define name="field_options">
    <element name="field">
      <a:documentation>Options describing a field (a prognostic function) in this system</a:documentation>
      <ref name="field_header_options"/>
      <element name="type">
        <a:documentation>The type of field (no option available).

Fields may only be prognostic functions.</a:documentation>
        <attribute name="name">
          <value>Function</value>
        </attribute>
        <choice>
          <element name="rank">
            <a:documentation>The rank of the field (scalar, rank 0).</a:documentation>
            <attribute name="name">
              <value>Scalar</value>
            </attribute>
            <ref name="scalar_field_function_options"/>
          </element>
          <element name="rank">
            <a:documentation>The rank of the field (vector, rank 1).</a:documentation>
            <attribute name="name">
              <value>Vector</value>
            </attribute>
            <ref name="vector_field_function_options"/>
          </element>
          <element name="rank">
            <a:documentation>The rank of the field (tensor, rank 2).</a:documentation>
            <attribute name="name">
              <value>Tensor</value>
            </attribute>
            <ref name="tensor_field_function_options"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <ref name="field_diagnostics_options"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="coefficient_options">
    <element name="coefficient">
      <a:documentation>Options describing a coefficient in this system</a:documentation>
      <ref name="coeff_header_options"/>
      <choice>
        <element name="type">
          <a:documentation>The type of coefficient.

Expressions are not defined on functionspaces but require an element to be described in ufl.</a:documentation>
          <attribute name="name">
            <value>Expression</value>
          </attribute>
          <choice>
            <element name="rank">
              <a:documentation>The rank of the coefficient (scalar, rank 0).</a:documentation>
              <attribute name="name">
                <value>Scalar</value>
              </attribute>
              <ref name="scalar_coefficient_expression_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (vector, rank 1).</a:documentation>
              <attribute name="name">
                <value>Vector</value>
              </attribute>
              <ref name="vector_coefficient_expression_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (tensor, rank 2).</a:documentation>
              <attribute name="name">
                <value>Tensor</value>
              </attribute>
              <ref name="tensor_coefficient_expression_options"/>
            </element>
          </choice>
          <ref name="comment"/>
        </element>
        <element name="type">
          <a:documentation>The type of coefficient.

Constants are spatially constant expressions.</a:documentation>
          <attribute name="name">
            <value>Constant</value>
          </attribute>
          <choice>
            <element name="rank">
              <a:documentation>The rank of the coefficient (scalar, rank 0).</a:documentation>
              <attribute name="name">
                <value>Scalar</value>
              </attribute>
              <ref name="scalar_coefficient_constant_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (vector, rank 1).</a:documentation>
              <attribute name="name">
                <value>Vector</value>
              </attribute>
              <ref name="vector_coefficient_constant_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (tensor, rank 2).</a:documentation>
              <attribute name="name">
                <value>Tensor</value>
              </attribute>
              <ref name="tensor_coefficient_constant_options"/>
            </element>
          </choice>
          <ref name="comment"/>
        </element>
        <element name="type">
          <a:documentation>The type of coefficient.

Functions require a functionspace, which will be defined on the same mesh as the system in which this coefficient falls.</a:documentation>
          <attribute name="name">
            <value>Function</value>
          </attribute>
          <choice>
            <element name="rank">
              <a:documentation>The rank of the coefficient (scalar, rank 0).</a:documentation>
              <attribute name="name">
                <value>Scalar</value>
              </attribute>
              <ref name="scalar_coefficient_function_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (vector, rank 1).</a:documentation>
              <attribute name="name">
                <value>Vector</value>
              </attribute>
              <ref name="vector_coefficient_function_options"/>
            </element>
            <element name="rank">
              <a:documentation>The rank of the coefficient (tensor, rank 2).</a:documentation>
              <attribute name="name">
                <value>Tensor</value>
              </attribute>
              <ref name="tensor_coefficient_function_options"/>
            </element>
          </choice>
          <ref name="comment"/>
        </element>
      </choice>
      <ref name="coeff_diagnostics_options"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="scalar_field_function_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="element_options_scalar"/>
    <zeroOrMore>
      <ref name="initial_condition_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="boundary_condition_scalar"/>
    </zeroOrMore>
    <optional>
      <ref name="reference_point_scalar"/>
    </optional>
    <optional>
      <ref name="zero_point_scalar"/>
    </optional>
    <optional>
      <ref name="value_cap_scalar"/>
    </optional>
    <ref name="comment"/>
  </define>
  <define name="vector_field_function_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="element_options_vector"/>
    <zeroOrMore>
      <ref name="initial_condition_vector"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="boundary_condition_vector"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="reference_point_tensor"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="zero_point_tensor"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="value_cap_tensor"/>
    </zeroOrMore>
    <ref name="comment"/>
  </define>
  <define name="tensor_field_function_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="element_options_tensor"/>
    <zeroOrMore>
      <ref name="initial_condition_tensor"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="boundary_condition_tensor"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="reference_point_tensor"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="zero_point_tensor"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="value_cap_tensor"/>
    </zeroOrMore>
    <ref name="comment"/>
  </define>
  <define name="field_manipulation_options">
    <optional>
      <element name="value_cap">
        <a:documentation>Cap the values of the field after every solve</a:documentation>
        <optional>
          <element name="upper_cap">
            <a:documentation>Do not let the maximum value exceed this cap</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="lower_cap">
            <a:documentation>Do not let the minimum value fall below this cap</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
    </optional>
  </define>
  <define name="scalar_coefficient_expression_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="element_options_scalar"/>
    <oneOrMore>
      <ref name="prescribed_expression_scalar"/>
    </oneOrMore>
    <ref name="comment"/>
  </define>
  <define name="vector_coefficient_expression_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="element_options_vector"/>
    <oneOrMore>
      <ref name="prescribed_expression_vector"/>
    </oneOrMore>
    <ref name="comment"/>
  </define>
  <define name="tensor_coefficient_expression_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="element_options_tensor"/>
    <oneOrMore>
      <ref name="prescribed_expression_tensor"/>
    </oneOrMore>
    <ref name="comment"/>
  </define>
  <define name="scalar_coefficient_function_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="element_options_scalar"/>
    <oneOrMore>
      <ref name="prescribed_function_scalar"/>
    </oneOrMore>
    <ref name="comment"/>
  </define>
  <define name="vector_coefficient_function_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="element_options_vector"/>
    <oneOrMore>
      <ref name="prescribed_function_vector"/>
    </oneOrMore>
    <ref name="comment"/>
  </define>
  <define name="tensor_coefficient_function_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="element_options_tensor"/>
    <oneOrMore>
      <ref name="prescribed_function_tensor"/>
    </oneOrMore>
    <ref name="comment"/>
  </define>
  <define name="scalar_coefficient_constant_options">
    <attribute name="rank">
      <value>0</value>
    </attribute>
    <ref name="prescribed_constant_scalar"/>
    <ref name="comment"/>
  </define>
  <define name="vector_coefficient_constant_options">
    <attribute name="rank">
      <value>1</value>
    </attribute>
    <ref name="prescribed_constant_vector"/>
    <ref name="comment"/>
  </define>
  <define name="tensor_coefficient_constant_options">
    <attribute name="rank">
      <value>2</value>
    </attribute>
    <ref name="prescribed_constant_tensor"/>
    <ref name="comment"/>
  </define>
  <define name="field_header_options">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <ref name="field_ufl_symbol"/>
  </define>
  <define name="coeff_header_options">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <ref name="coeff_ufl_symbol"/>
  </define>
  <define name="field_diagnostics_options">
    <element name="diagnostics">
      <a:documentation>Output options</a:documentation>
      <optional>
        <element name="include_in_visualization">
          <a:documentation>Include this field in the visualization output file.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="include_in_statistics">
          <a:documentation>Include this field in the statistics output file.
The minimum and maximum of functions is included.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in the steady state check and output file.</a:documentation>
          <element name="norm">
            <a:documentation>Norm to test for a steady state in </a:documentation>
            <!-- a hard coded string_value -->
            <element name="string_value">
              <!--
                Lines is a hint to the gui about the size of the text box.
                It is not an enforced limit on string length.
              -->
              <attribute name="lines">
                <value>1</value>
              </attribute>
              <choice>
                <value>linf</value>
                <value>l2</value>
                <value>l1</value>
              </choice>
            </element>
            <ref name="comment"/>
          </element>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="include_in_detectors">
          <a:documentation>Include this field in the detectors output file.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="include_residual_in_visualization">
          <a:documentation>Include the residual of this field in a visualization output file.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="coeff_diagnostics_options">
    <element name="diagnostics">
      <a:documentation>Output options</a:documentation>
      <optional>
        <element name="include_in_statistics">
          <a:documentation>Include this coefficient in the statistics output file.
The minimum and maximum (evaluated at the vertices of the mesh) 
of functions is included.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="include_in_detectors">
          <a:documentation>Include this coefficient in the detectors output file.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="initial_condition_scalar">
    <choice>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over the whole domain

If unspecified the initial value will be set to 0.

NOTE: this initial condition will be interpolated onto the dofs.  Some elements do not support this so you should instead
solve the system at the start of the simulation to set the initial condition.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>initial_condition</value>
        </attribute>
        <ref name="prescribed_scalar_w_file"/>
        <ref name="comment"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over a subset of the whole domain

If unspecified the initial value will be set to 0.

NOTE: this initial condition will be interpolated onto the dofs.  Some elements do not support this so you should instead
solve the system at the start of the simulation to set the initial condition.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>initial_condition</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this  condition applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_scalar"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="initial_condition_vector">
    <choice>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over the whole domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>initial_condition</value>
        </attribute>
        <ref name="prescribed_vector_w_file"/>
        <ref name="comment"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over a subset of the whole domain</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>initial_condition</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this condition applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_vector"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="initial_condition_tensor">
    <choice>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over the whole domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>initial_condition</value>
        </attribute>
        <ref name="prescribed_tensor_w_file"/>
        <ref name="comment"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Options for the description of the initial condition over a subset of the whole domain</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>initial_condition</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this condition applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_tensor"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="boundary_condition_scalar">
    <element name="boundary_condition">
      <a:documentation>Options for the description of a boundary condition</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh) that this condition applies to  </a:documentation>
        <ref name="integer_vector"/>
      </element>
      <element name="sub_components">
        <a:documentation>There are no sub components to a scalar so this is just a dummy tree level for consistency with a vector function</a:documentation>
        <attribute name="name">
          <value>All</value>
        </attribute>
        <element name="type">
          <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
          <attribute name="name">
            <value>Dirichlet</value>
          </attribute>
          <attribute name="type">
            <value>boundary_condition</value>
          </attribute>
          <ref name="prescribed_scalar_w_internal_reference"/>
          <ref name="comment"/>
        </element>
        <ref name="comment"/>
      </element>
      <ref name="comment"/>
    </element>
  </define>
  <define name="boundary_condition_vector">
    <element name="boundary_condition">
      <a:documentation>Options for the description of a boundary condition</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh) that this condition applies to  </a:documentation>
        <ref name="integer_vector"/>
      </element>
      <oneOrMore>
        <choice>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to all the vector components on this boundary_id</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <attribute name="type">
                <value>boundary_condition</value>
              </attribute>
              <ref name="prescribed_vector_w_internal_reference"/>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to a subset of the vector components on this boundary_id</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector components to which this boundary condition applies (indexes from 0)</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <attribute name="type">
                <value>boundary_condition</value>
              </attribute>
              <ref name="prescribed_scalar_w_internal_reference"/>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
        </choice>
      </oneOrMore>
      <ref name="comment"/>
    </element>
  </define>
  <define name="boundary_condition_tensor">
    <element name="boundary_condition">
      <a:documentation>Options for the description of a boundary condition</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="boundary_ids">
        <a:documentation>A list of the boundary ids (physical ids in gmsh) that this condition applies to  </a:documentation>
        <ref name="integer_vector"/>
      </element>
      <oneOrMore>
        <choice>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to all the tensor components on this boundary_id</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <attribute name="type">
                <value>boundary_condition</value>
              </attribute>
              <ref name="prescribed_tensor_w_internal_reference"/>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Apply this boundary condition to a subset of the tensor components on this boundary_id</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="components">
              <a:documentation>A list of the tensor components to which this boundary condition applies (indexes from 0 by row first)</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="type">
              <a:documentation>The boundary condition type (only strong Dirichlet available).</a:documentation>
              <attribute name="name">
                <value>Dirichlet</value>
              </attribute>
              <attribute name="type">
                <value>boundary_condition</value>
              </attribute>
              <ref name="prescribed_scalar_w_internal_reference"/>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
        </choice>
      </oneOrMore>
      <ref name="comment"/>
    </element>
  </define>
  <define name="reference_point_scalar">
    <element name="reference_point">
      <a:documentation>Options for the description of a reference point at which field values are zeroed during each solve 
by the imposition of an internal pointwise Dirichlet boundary condition at the nearest node to the
coordinates specified below.</a:documentation>
      <attribute name="name">
        <value>Point</value>
      </attribute>
      <element name="coordinates">
        <a:documentation>The coordinates of the reference point.  The node nearest these coordinates will be used.</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <ref name="comment"/>
    </element>
  </define>
  <define name="reference_point_tensor">
    <choice>
      <element name="reference_point">
        <a:documentation>Options for the description of a reference point at which field values are zeroed during each solve 
by the imposition of an internal pointwise Dirichlet boundary condition at the nearest node to the
coordinates specified below.

This version defaults to the name Point.  If specifying more than one reference point (perhaps on different components) the name of each 
one must be unique so multiple instances of this default name are not allowed.</a:documentation>
        <attribute name="name">
          <value>Point</value>
        </attribute>
        <element name="coordinates">
          <a:documentation>The coordinates of the reference point.  The node nearest these coordinates will be used.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
        <choice>
          <element name="sub_components">
            <a:documentation>Zero all the vector/tensor components at this reference point.</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Zero a subset of the vector/tensor components at this reference point.</a:documentation>
            <attribute name="name">
              <value>Subset</value>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <element name="reference_point">
        <a:documentation>Options for the description of a reference point at which field values are zeroed during each solve 
by the imposition of an internal pointwise Dirichlet boundary condition at the nearest node to the
coordinates specified below.

Names of each reference point (perhaps on different components) must be unique within this field specification.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="coordinates">
          <a:documentation>The coordinates of the reference point.  The node nearest these coordinates will be used.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
        <choice>
          <element name="sub_components">
            <a:documentation>Zero a subset of the vector/tensor components at this reference point.</a:documentation>
            <attribute name="name">
              <value>Subset</value>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Zero all the vector/tensor components at this reference point.</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="zero_point_scalar">
    <element name="zero_point">
      <a:documentation>Options for the description of a zero point at which field values are zeroed after each nonlinear solve.

Unlike reference points, a zero point is a post-processing calculation and so should be used in conjunction 
with a Lagrange multiplier or the removal of the null space if the solution would be ill conditioned otherwise.</a:documentation>
      <attribute name="name">
        <value>Point</value>
      </attribute>
      <element name="coordinates">
        <a:documentation>The coordinates of the reference point.  The node nearest these coordinates will be used.</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <ref name="comment"/>
    </element>
  </define>
  <define name="zero_point_tensor">
    <choice>
      <element name="zero_point">
        <a:documentation>Options for the description of a zero point at which field values are zeroed after each nonlinear solve.

Unlike reference points, a zero point is a post-processing calculation and so should be used in conjunction 
with a Lagrange multiplier or the removal of the null space if the solution would be ill conditioned otherwise.

This version defaults to the name Point.  If specifying more than one reference point the name of each 
one must be unique so multiple instances of this default name are not allowed.</a:documentation>
        <attribute name="name">
          <value>Point</value>
        </attribute>
        <element name="coordinates">
          <a:documentation>The coordinates of the zero point.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
        <choice>
          <element name="sub_components">
            <a:documentation>Zero all the vector/tensor components at this zero point.</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Zero a subset of the vector/tensor components at this zero point.</a:documentation>
            <attribute name="name">
              <value>Subset</value>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector/tensor components to which this zero point applies (indexes from 0 by row first for tensors).</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <element name="zero_point">
        <a:documentation>Options for the description of a zero point at which field values are zeroed after each nonlinear solve.

Unlike reference points, a zero point is a post-processing calculation and so should be used in conjunction 
with a Lagrange multiplier or the removal of the null space if the solution would be ill conditioned otherwise.

If specifying multiple zero points (perhaps on different components) their names must be unique within this field specification.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="coordinates">
          <a:documentation>The coordinates of the zero point.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
        <choice>
          <element name="sub_components">
            <a:documentation>Zero a subset of the vector/tensor components at this reference point.</a:documentation>
            <attribute name="name">
              <value>Subset</value>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Zero all the vector/tensor components at this reference point.</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="value_cap_scalar">
    <element name="value_cap">
      <a:documentation>Cap the values of the field after every nonlinear solve.

This is a postprocessing modification of the vector values and so will affect the value of the non-linear residual.  
In a coupled problem this will likely have implications on the other fields that this simple hack will not consider.  
Perhaps consider using SNES VI instead.</a:documentation>
      <attribute name="name">
        <value>Cap</value>
      </attribute>
      <optional>
        <element name="upper_cap">
          <a:documentation>Do not let the maximum value exceed this cap</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Do not let the minimum value fall below this cap</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="value_cap_tensor">
    <choice>
      <element name="value_cap">
        <a:documentation>Cap the values of the field after every nonlinear solve.

This is a postprocessing modification of the vector values and so will affect the value of the non-linear residual.  
In a coupled problem this will likely have implications on the other fields that this simple hack will not consider.  
Perhaps consider using SNES VI instead.

This version defaults to the name Cap.  If specifying more than one value cap (perhaps on different components) the name of each 
one must be unique so multiple instances of this default name are not allowed.</a:documentation>
        <attribute name="name">
          <value>Cap</value>
        </attribute>
        <optional>
          <element name="upper_cap">
            <a:documentation>Do not let the maximum value exceed this cap</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="lower_cap">
            <a:documentation>Do not let the minimum value fall below this cap</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <choice>
          <element name="sub_components">
            <a:documentation>Cap all the vector/tensor components.</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Cap a subset of the vector/tensor components.</a:documentation>
            <attribute name="name">
              <value>Subset</value>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <element name="value_cap">
        <a:documentation>Cap the values of the field after every nonlinear solve.

This is a postprocessing modification of the vector values and so will affect the value of the non-linear residual.  
In a coupled problem this will likely have implications on the other fields that this simple hack will not consider.  
Perhaps consider using SNES VI instead.

If specifying multiple value caps (perhaps on different components) their names must be unique within this field specification.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="upper_cap">
            <a:documentation>Do not let the maximum value exceed this cap</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="lower_cap">
            <a:documentation>Do not let the minimum value fall below this cap</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <choice>
          <element name="sub_components">
            <a:documentation>Cap all the vector/tensor components.</a:documentation>
            <attribute name="name">
              <value>All</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="sub_components">
            <a:documentation>Cap a subset of the vector/tensor components.</a:documentation>
            <attribute name="name">
              <value>Subset</value>
            </attribute>
            <element name="components">
              <a:documentation>A list of the vector/tensor components to which this reference point applies (indexes from 0 by row first for tensors).</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_constant_scalar">
    <element name="value">
      <a:documentation>Options for the description of an expression over the domain</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <attribute name="type">
        <value>value</value>
      </attribute>
      <ref name="prescribed_scalar_constant_w_functional"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_constant_vector">
    <element name="value">
      <a:documentation>Options for the description of an expression over the domain</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <attribute name="type">
        <value>value</value>
      </attribute>
      <ref name="prescribed_vector_constant"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_constant_tensor">
    <element name="value">
      <a:documentation>Options for the description of an expression over the domain</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <attribute name="type">
        <value>value</value>
      </attribute>
      <ref name="prescribed_tensor_constant"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_expression_scalar">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <ref name="prescribed_scalar_w_internal"/>
        <ref name="comment"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_scalar_w_internal"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_expression_vector">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <ref name="prescribed_vector_w_internal"/>
        <ref name="comment"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_vector_w_internal"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_expression_tensor">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <ref name="prescribed_tensor_w_internal"/>
        <ref name="comment"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_tensor_w_internal"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_function_scalar">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <ref name="prescribed_scalar_time_w_internal"/>
        <ref name="comment"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_scalar_time_w_internal"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_function_vector">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <ref name="prescribed_vector_time_w_internal"/>
        <ref name="comment"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_vector_time_w_internal"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_function_tensor">
    <choice>
      <element name="value">
        <a:documentation>Options for the description of an expression over the domain</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <ref name="prescribed_tensor_time_w_internal"/>
        <ref name="comment"/>
      </element>
      <element name="value">
        <a:documentation>Options for the description of an expression over regions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <attribute name="type">
          <value>value</value>
        </attribute>
        <element name="region_ids">
          <a:documentation>A list of the region ids (physical ids in gmsh) that this expression applies to</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="prescribed_tensor_time_w_internal"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_scalar_constant">
    <element name="constant">
      <a:documentation>A constant scalar</a:documentation>
      <ref name="real"/>
    </element>
  </define>
  <define name="prescribed_scalar_functional">
    <element name="functional">
      <a:documentation>ufl code and symbol describing a functional.  This must return a single number, which is used to set a spatially constant coefficient value.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="python_code"/>
      <ref name="functional_ufl_symbol"/>
      <ref name="quadrature_degree"/>
      <ref name="quadrature_rule"/>
    </element>
  </define>
  <define name="prescribed_scalar_constant_w_functional">
    <ref name="prescribed_scalar_functional"/>
  </define>
  <define name="prescribed_scalar_constant_w_functional" combine="choice">
    <ref name="prescribed_scalar_constant"/>
  </define>
  <define name="prescribed_vector_constant">
    <choice>
      <element name="constant">
        <a:documentation>A constant vector of length /geometry/dimension</a:documentation>
        <attribute name="name">
          <value>dim</value>
        </attribute>
        <ref name="real_dim_vector"/>
      </element>
      <element name="constant">
        <a:documentation>A constant vector of arbitrary length (must be the same as the size of the vector element).</a:documentation>
        <attribute name="name">
          <value>arbitrary</value>
        </attribute>
        <ref name="real_vector"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_tensor_constant">
    <choice>
      <element name="constant">
        <a:documentation>A constant tensor of shape /geometry/dimension x /geometry/dimension</a:documentation>
        <attribute name="name">
          <value>dim</value>
        </attribute>
        <ref name="real_dim_tensor"/>
      </element>
      <element name="constant">
        <a:documentation>A constant tensor of arbitrary shape (must be the same as the size of the tensor element).  
Values should be entered by row first.</a:documentation>
        <attribute name="name">
          <value>arbitrary</value>
        </attribute>
        <ref name="real_tensor"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_scalar_python">
    <element name="python">
      <a:documentation>A scalar described by a python function.

Functions should be of the form:

    def val(x):
      # Function code
      return ... # Return value

 for steady (time independent) expressions or:

    def val(x,t):
      # Function code
      return ... # Return value

 for time dependent expressions.

The return value should be scalar.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="prescribed_vector_python">
    <element name="python">
      <a:documentation>A vector described by a python function.

Functions should be of the form:

    def val(x):
      # Function code
      return [..., ...] # Return value

 for steady (time independent) expressions or:

    def val(x,t):
      # Function code
      return [..., ...] # Return value

 for time dependent expressions.

The return value must have the same size as the vector element.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="prescribed_tensor_python">
    <element name="python">
      <a:documentation>A tensor described by a python function.

Functions should be of the form:

    def val(x):
      # Function code
      return [[..., ...],[..., ...],...] # Return value

 for steady (time independent) expressions or:

    def val(x,t):
      # Function code
      return [[..., ...],[..., ...],...] # Return value

 for time dependent expressions.

The return value must have the same shape as the tensor element.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="prescribed_cpp">
    <optional>
      <element name="include">
        <a:documentation>Additional headers that are required for this expression.

These should be listed including an include statement, e.g.:

    #include &lt;string&gt;
    #include "example.h"

The expression will automatically include:

    #include "BoostTypes.h"
    #include "Bucket.h"
    #include "SystemBucket.h"
    #include &lt;dolfin.h&gt;</a:documentation>
        <ref name="cpp_code"/>
      </element>
    </optional>
    <element name="members">
      <a:documentation>Private members of this expression. These are variables that will be used in the eval
function for this expression but that you don't want initialized at every call to the eval
(expensive).  They should therefore be declared here and initialized in the initialization 
routines below.

The use of underscores at the end of variable names is discouraged as these are frequesntly used for 
automatically generated variables.  Additionally the overloaded dolfin eval interface provides
variables named values, x and cell, so these should not be used to avoid confusion.</a:documentation>
      <ref name="cpp_code"/>
    </element>
    <element name="initialization">
      <a:documentation>Initialization routine for the private members declared above.

This initialization has full access to publicly accessible members of the bucket through
the automatically provided bucket() function, which returns a pointer to the bucket class.  
A shortcut to the members of this system is provided through the system() function, which 
returns a pointer to this system class.  Finally, a boost shared pointer to the time is
provided through the time() function.

The recommended way of accessing functions is through the function_ptr(time()) interface for
systems and the genericfunction_ptr(time()) interface for fields and coefficients.  These return
a boost shared pointer to a dolfin function or generic function respectively.  Importantly however,
the time() argument will ensure that when this expression is evaluated the appropriate timelevel of 
dependent function or generic function is also used. *time() may also be used to make the expression
dependent on time.

For example, to extract a boost shared pointer to a generic function for a coefficient called 
"ExampleCoefficient", we should have declared in the members section above:

    std::shared_pointer&lt; dolfin::GenericFunction &gt; examplecoeff;

or (utilizing the typedefs available to us through BoostTypes.h:

    GenericFunction_ptr examplecoeff;

Then, in this initialization function, we could extract the appropriate time level of that 
coefficient from the "ExampleSystem" system using:

    examplecoeff = bucket()-&gt;fetch_system("ExampleSystem")-&gt;fetch_coeff("ExampleCoefficient")-&gt;genericfunction_ptr(time())

or, if "ExampleSystem" is the current system, using the shortcut:

    examplecoeff = system()-&gt;fetch_coeff("ExampleCoefficient")-&gt;genericfunction_ptr(time())</a:documentation>
      <ref name="cpp_code"/>
    </element>
    <element name="eval">
      <a:documentation>Overload the eval subroutine for this expression.  This has the standard interface for DOLFIN 
expressions, i.e.:

    void eval(dolfin::Array&lt;double&gt;&amp; values, const dolfin::Array&lt;double&gt;&amp; x, const ufc::cell &amp;cell) const

To automatically evaluate and return the values of the "ExampleCoefficient" in the example in the 
initialization section, all that would be required to write here is:

    examplecoeff.eval(values, x, cell);

(assuming examplecoeff and this expression are of appropriately matched rank, shape and size).</a:documentation>
      <ref name="cpp_code"/>
    </element>
    <ref name="comment"/>
  </define>
  <define name="time_independent_cpp">
    <optional>
      <element name="time_independent">
        <a:documentation>cpp functions are automatically assumed to be time varying.  

Turning on this option means they only get evaluated once (at
the start of the simtulation).</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prescribed_cpp_time">
    <ref name="prescribed_cpp"/>
  </define>
  <define name="prescribed_cpp_time" combine="interleave">
    <ref name="time_independent_cpp"/>
  </define>
  <define name="prescribed_scalar_cpp">
    <element name="cpp">
      <a:documentation>A scalar described by a derived dolfin expression using c++ code.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="prescribed_cpp"/>
    </element>
  </define>
  <define name="prescribed_vector_cpp">
    <element name="cpp">
      <a:documentation>A vector described by a derived dolfin expression using c++ code.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="prescribed_cpp"/>
    </element>
  </define>
  <define name="prescribed_tensor_cpp">
    <element name="cpp">
      <a:documentation>A tensor described by a derived dolfin expression using c++ code.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="prescribed_cpp"/>
    </element>
  </define>
  <define name="prescribed_scalar_cpp_time">
    <element name="cpp">
      <a:documentation>A scalar described by a derived dolfin expression using c++ code.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="prescribed_cpp_time"/>
    </element>
  </define>
  <define name="prescribed_vector_cpp_time">
    <element name="cpp">
      <a:documentation>A vector described by a derived dolfin expression using c++ code.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="prescribed_cpp_time"/>
    </element>
  </define>
  <define name="prescribed_tensor_cpp_time">
    <element name="cpp">
      <a:documentation>A tensor described by a derived dolfin expression using c++ code.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="prescribed_cpp_time"/>
    </element>
  </define>
  <define name="prescribed_internal_semilagrangian">
    <element name="algorithm">
      <a:documentation>A semilagrangian lookup algorithm</a:documentation>
      <attribute name="name">
        <value>SemiLagrangian</value>
      </attribute>
      <element name="lookup_function">
        <a:documentation>The function that will be looked up (normally a field).

Note that the algorithm will always look up the value of the function at the previous timestep.</a:documentation>
        <optional>
          <element name="system">
            <a:documentation>The system where the function is to be found.
Assumed to be the current system if left unspecified.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </optional>
        <choice>
          <element name="field">
            <a:documentation>The field name.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="coefficient">
            <a:documentation>The coefficient name.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <element name="velocity">
        <a:documentation>The velocity that will be used to lookup the value.

This must have the same dimension as the geometry.</a:documentation>
        <optional>
          <element name="system">
            <a:documentation>The system where the velocity is to be found.
Assumed to be the current system if left unspecified.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </optional>
        <choice>
          <element name="field">
            <a:documentation>The field name.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="coefficient">
            <a:documentation>The coefficient name.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <element name="outside_value">
        <a:documentation>The value that will be used when the lookup point falls outside the mesh.

Most likely this should be a coefficient expression or constant (i.e. not restricted to the system's mesh).</a:documentation>
        <optional>
          <element name="system">
            <a:documentation>The system where the function is to be found.
Assumed to be the current system if left unspecified.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </optional>
        <choice>
          <element name="coefficient">
            <a:documentation>The coefficient name.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="field">
            <a:documentation>The field name.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <ref name="comment"/>
      </element>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_scalar_internal_semilagrangian">
    <element name="internal">
      <a:documentation>A scalar described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="prescribed_internal_semilagrangian"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_vector_internal_semilagrangian">
    <element name="internal">
      <a:documentation>A vector described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="prescribed_internal_semilagrangian"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_tensor_internal_semilagrangian">
    <element name="internal">
      <a:documentation>A tensor described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="prescribed_internal_semilagrangian"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_internal_reference">
    <element name="algorithm">
      <a:documentation>An algorithm that allows the user to reference a field or coefficient of the same rank.</a:documentation>
      <attribute name="name">
        <value>Reference</value>
      </attribute>
      <optional>
        <element name="system">
          <a:documentation>The system where the function is to be found.
Assumed to be the current system if left unspecified.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </optional>
      <choice>
        <element name="field">
          <a:documentation>The field name.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="comment"/>
        </element>
        <element name="coefficient">
          <a:documentation>The coefficient name.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </choice>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_scalar_internal_reference">
    <element name="internal">
      <a:documentation>A scalar described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="prescribed_internal_reference"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_vector_internal_reference">
    <element name="internal">
      <a:documentation>A vector described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="prescribed_internal_reference"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_tensor_internal_reference">
    <element name="internal">
      <a:documentation>A tensor described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="prescribed_internal_reference"/>
      <ref name="comment"/>
    </element>
  </define>
  <!-- prescribed_internal = prescribed_internal_reference   # not yet ready for this! -->
  <define name="prescribed_internal">
    <ref name="prescribed_internal_semilagrangian"/>
  </define>
  <define name="prescribed_scalar_internal">
    <element name="internal">
      <a:documentation>A scalar described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <ref name="prescribed_internal"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_vector_internal">
    <element name="internal">
      <a:documentation>A vector described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <ref name="prescribed_internal"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_tensor_internal">
    <element name="internal">
      <a:documentation>A tensor described by an internal derived dolfin expression.</a:documentation>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <ref name="prescribed_internal"/>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prescribed_file">
    <element name="file">
      <a:documentation>Give the name of a checkpoint file.  All fields in a system must share this file
and the functionspace must be identical to the original system's functionspace.</a:documentation>
      <ref name="anystring"/>
    </element>
  </define>
  <define name="prescribed_scalar">
    <ref name="prescribed_scalar_cpp"/>
  </define>
  <define name="prescribed_scalar" combine="choice">
    <ref name="prescribed_scalar_python"/>
  </define>
  <define name="prescribed_scalar" combine="choice">
    <ref name="prescribed_scalar_constant"/>
  </define>
  <define name="prescribed_scalar_w_internal_reference">
    <ref name="prescribed_scalar_internal_reference"/>
  </define>
  <define name="prescribed_scalar_w_internal_reference" combine="choice">
    <ref name="prescribed_scalar"/>
  </define>
  <define name="prescribed_scalar_w_internal">
    <ref name="prescribed_scalar_internal"/>
  </define>
  <define name="prescribed_scalar_w_internal" combine="choice">
    <ref name="prescribed_scalar"/>
  </define>
  <define name="prescribed_scalar_w_file">
    <ref name="prescribed_file"/>
  </define>
  <define name="prescribed_scalar_w_file" combine="choice">
    <ref name="prescribed_scalar"/>
  </define>
  <define name="prescribed_scalar_time">
    <ref name="prescribed_scalar_cpp_time"/>
  </define>
  <define name="prescribed_scalar_time" combine="choice">
    <ref name="prescribed_scalar_python"/>
  </define>
  <define name="prescribed_scalar_time" combine="choice">
    <ref name="prescribed_scalar_constant"/>
  </define>
  <define name="prescribed_scalar_time_w_internal">
    <ref name="prescribed_scalar_internal"/>
  </define>
  <define name="prescribed_scalar_time_w_internal" combine="choice">
    <ref name="prescribed_scalar_time"/>
  </define>
  <define name="prescribed_scalar_w_internal_reference">
    <ref name="prescribed_scalar_internal_reference"/>
  </define>
  <define name="prescribed_scalar_w_internal_reference" combine="choice">
    <ref name="prescribed_scalar"/>
  </define>
  <define name="prescribed_vector">
    <ref name="prescribed_vector_cpp"/>
  </define>
  <define name="prescribed_vector" combine="choice">
    <ref name="prescribed_vector_python"/>
  </define>
  <define name="prescribed_vector" combine="choice">
    <ref name="prescribed_vector_constant"/>
  </define>
  <define name="prescribed_vector_w_internal_reference">
    <ref name="prescribed_vector_internal_reference"/>
  </define>
  <define name="prescribed_vector_w_internal_reference" combine="choice">
    <ref name="prescribed_vector"/>
  </define>
  <define name="prescribed_vector_w_internal">
    <ref name="prescribed_vector_internal"/>
  </define>
  <define name="prescribed_vector_w_internal" combine="choice">
    <ref name="prescribed_vector"/>
  </define>
  <define name="prescribed_vector_w_file">
    <ref name="prescribed_file"/>
  </define>
  <define name="prescribed_vector_w_file" combine="choice">
    <ref name="prescribed_vector"/>
  </define>
  <define name="prescribed_vector_time">
    <ref name="prescribed_vector_cpp_time"/>
  </define>
  <define name="prescribed_vector_time" combine="choice">
    <ref name="prescribed_vector_python"/>
  </define>
  <define name="prescribed_vector_time" combine="choice">
    <ref name="prescribed_vector_constant"/>
  </define>
  <define name="prescribed_vector_time_w_internal">
    <ref name="prescribed_vector_internal"/>
  </define>
  <define name="prescribed_vector_time_w_internal" combine="choice">
    <ref name="prescribed_vector_time"/>
  </define>
  <define name="prescribed_tensor">
    <ref name="prescribed_tensor_cpp"/>
  </define>
  <define name="prescribed_tensor" combine="choice">
    <ref name="prescribed_tensor_python"/>
  </define>
  <define name="prescribed_tensor" combine="choice">
    <ref name="prescribed_tensor_constant"/>
  </define>
  <define name="prescribed_tensor_w_internal_reference">
    <ref name="prescribed_tensor_internal_reference"/>
  </define>
  <define name="prescribed_tensor_w_internal_reference" combine="choice">
    <ref name="prescribed_tensor"/>
  </define>
  <define name="prescribed_tensor_w_internal">
    <ref name="prescribed_tensor_internal"/>
  </define>
  <define name="prescribed_tensor_w_internal" combine="choice">
    <ref name="prescribed_tensor"/>
  </define>
  <define name="prescribed_tensor_w_file">
    <ref name="prescribed_file"/>
  </define>
  <define name="prescribed_tensor_w_file" combine="choice">
    <ref name="prescribed_tensor"/>
  </define>
  <define name="prescribed_tensor_time">
    <ref name="prescribed_tensor_cpp_time"/>
  </define>
  <define name="prescribed_tensor_time" combine="choice">
    <ref name="prescribed_tensor_python"/>
  </define>
  <define name="prescribed_tensor_time" combine="choice">
    <ref name="prescribed_tensor_constant"/>
  </define>
  <define name="prescribed_tensor_time_w_internal">
    <ref name="prescribed_tensor_internal"/>
  </define>
  <define name="prescribed_tensor_time_w_internal" combine="choice">
    <ref name="prescribed_tensor_time"/>
  </define>
</grammar>
