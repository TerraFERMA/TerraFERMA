#!/usr/bin/env python3

# Copyright (C) 2013 Columbia University in the City of New York and others.
#
# Please see the AUTHORS file in the main source directory for a full list
# of contributors.
#
# This file is part of TerraFERMA.
#
# TerraFERMA is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TerraFERMA is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with TerraFERMA. If not, see <http://www.gnu.org/licenses/>.

import os
from buckettools import xdmftools

if __name__ == "__main__":
  import argparse
  import os

  parser = argparse.ArgumentParser( \
                         description="""Convert from a .xdmf file to a .vtu.""")
  parser.add_argument('filename', action='store', metavar='filename', type=str,
                      help='specify a .xdmf filename')
  parser.add_argument('-vtu', '--outputvtu', action='store', metavar='vtufilename', type=str, default=False, const=None, required=False, nargs='?',
                      help='convert to vtu (with pvd where possible) with optional given vtufilename or basename  (defaults to filename*.vtu and filename.pvd)')
  parser.add_argument('-pvd', '--outputpvd', action='store', metavar='pvdfilename', type=str, default=False, const=None, required=False, nargs='?',
                      help='generate a pvd with optional given pvdfilename or basename  (defaults to filename.pvd)')
  parser.add_argument('-f', '--fieldname', action='store', metavar='fieldname', type=str, default=None, required=False, nargs='*',
                      help='name of the fields to include in the vtu (defaults to all fields)')
  parser.add_argument('-ti', '--tindex', action='store', metavar='ti', type=int, default=None, required=False, nargs='*',
                      help='time indices to be converted (defaults to all times, ignored if --tirange, --time or --trange provided)')
  parser.add_argument('-tir', '--tirange', action='store', metavar=('tibegin', 'tiend'), type=int, default=None, required=False, nargs=2,
                      help='range of time indices to be converted (defaults to all times, ignored if --time or --trange provided, overrides --tindex)')
  parser.add_argument('-t', '--time', action='store', metavar='time', type=float, default=None, required=False, nargs='*',
                      help='search for the nearest times to be converted (defaults to all times, ignored if --trange provided, overrides --tindex, --tirange)')
  parser.add_argument('-tr', '--trange', action='store', metavar=('tbegin', 'tiend'), type=float, default=None, required=False, nargs=2,
                      help='range of times to be converted (defaults to all times, overrides --tindex, --tirange, --time)')
  parser.add_argument('-i', '--index', action='store', metavar='index', type=int, default=None, required=False,
                      help='index of output when multiple instances are included per timestep (defaults to all availble in each timestep)')
  parser.add_argument('--family', action='store', metavar='family', type=str, default=None, required=False,
                      help='family (CG or DG) to interpolate functions to (only applies to checkpoint xdmfs and defaults to DG if discontinuous fields are present)')
  parser.add_argument('--degree', action='store', metavar='degree', type=int, default=None, required=False,
                      help='degree (1 or 2) to interpolate functions to (only applies to checkpoint xdmfs and defaults to minimum of highest degree present and 2)')
  args = parser.parse_args()

  basename, ext = os.path.splitext(args.filename)
  if ext != '.xdmf':
    raise Exception("ERROR: Unknown input extension: {}".format(ext,))

  xdmf = xdmftools.XDMF(args.filename)

  tindices = args.tindex
  if args.tirange is not None:
    xdmftimes = xdmf.gettimes()
    tirange = [len(xdmftimes)+ti if ti < 0 else min(ti, len(xdmftimes)) for ti in args.tirange]
    tindices = list(range(tirange[0], tirange[1]))
  times = args.time
  if args.trange is not None:
    xdmftimes = xdmf.gettimes()
    trange = [min(t, xdmftimes[-1]) for t in args.trange]
    tirange = [np.abs(xdmftimes-t).argmin() for t in trange]
    times = xdmftimes[tirange[0], tirange[1]+1]

  if args.outputvtu is not False:
    xdmf.pvd(names=args.fieldname, tindices=tindices, times=times, indices=args.index, family=args.family, degree=args.degree, writefile=args.outputvtu)
  elif args.outputpvd is not False:
    xdmf.generate_pvd(names=args.fieldname, tindices=tindices, times=times, indices=args.index, family=args.family, degree=args.degree, writefile=args.outputpvd)
